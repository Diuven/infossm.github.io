---
layout: post
title:  "알고리즘 문제 접근 과정 8"
date:   2022-02-18 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 8

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [버스 노선 - KOI 2014 고등부 2번](https://www.acmicpc.net/problem/10165)

## 풀이

이 문제를 해결하는데 큰 어려움이 되는 부분은 구간이 원형으로 되어있다는 점일 것입니다.
그렇다면 일단, 문제가 원형으로 생겨있지 않고 0번을 기준으로 일직선으로 생긴 형태라면 어떻게 해결할 수 있을까요?

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_8_1.PNG)

간단히, 위와 같이 생긴 일직선 구간들로만 이루어진 노선들이 존재할 경우, 특정 구간이 다른 구간에 포함된다는 것을 어떻게 찾을 수 있을까요?
가장 쉬운 방법으로는, 한 구간을 잡고 다른 모든 구간에 대해 비교하면서 현 구간을 포함하는 다른 구간이 있는지 확인하는 것으로 해결할 수 있습니다.
이 방법으로는 O(N^2)에 해결할 수 있지만, 노선의 수가 많을 경우 충분히 빠르게 동작하지 않을 수 있습니다. 그렇다면, 어떻게 더 빠르게 해결할 수 있을까요?

주어진 노선들을 시작점이 빠른 순서대로 정렬해줍시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_8_2.PNG)

위와 같이 정렬하고 나면, 우리는 노선을 앞에서부터 순서대로 볼 때에 뒤에 나오는 노선의 시작점은 항상 앞에 나온 노선들보다 늦고, 그 뒤에 나올 노선들보다는 항상 빠르다는 것을 알 수 있습니다.
즉, 특정 노선이 포함되기 위해서는 시작점과 끝점 모두가 포함되어야 하므로, 순서대로 진행할 때 현재 우리가 보고있는 노선을 포함할 수 있는 노선은 항상 앞에나온 노선 중에 있거나 혹은 존재하지 않는다는 것을 알 수 있습니다.

- ex) 4번 노선은 시작점이 늦는 2번이나 3번은 아무리 끝점이 길어도 포함 불가

이를 통해 순서대로 진행하면서 현재까지 나온 노선들 중 끝 구간의 번호가 가장 큰 값을 저장하고 있으면, 이후에 나오는 노선의 끝 구간이 더 작을 경우 항상 포함하는 노선이 존재함을 알 수 있어 특정 노선이 취소되는지 여부를 바로 확인할 수 있습니다.
여기에서 시작점이 같을 경우에 문제가 생길 수 있지 않은지 생각해볼 필요가 있습니다. 시작점이 같은 때에는 끝 지점을 모르는 상태에서 누가 누구를 포함할지 알 수 없기 때문에 꼭 시작점 순서대로 포함이 되는 것이 아닐 수 있습니다. 하지만 여기서, 시작 구간이 같을 경우 끝 구간이 늦은 쪽이 항상 다른 모든 같은 시작구간인 노선을 포함할 수 있다는 것을 이용해 시작이 같을 경우 끝이 늦는 노선이 먼저 오도록 정렬을 해주면 이 문제를 해결할 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_8_3.PNG)

<center>(왼쪽의 경우 세 번째 노선이 나머지를 다 포함하지만, 오른쪽처럼 정렬시 그런 경우 X)</center>

이를 통해 모든 경우에 대해 항상 특정 노선이 포함되는지 여부를 알 수 있으며, 모든 과정은 정렬을 하는 때에 가장 많은 시간이 들어 총 $O(NlgN)$에 해결할 수 있습니다.

하지만 아직 우린 원형일 때의 문제를 해결하지 못했다. 혹시 문제를 잘 변형하는 것으로 선형일 때 해결한 방법을 원형에도 적용할 수 있을까요?

예시 그림을 한 번 살펴봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_8_4.PNG)

위 그림에서 5번 노선은 $[9, 4]$인 형태로 주어지며, 1번 노선 $[0, 4]$를 포함하있고, 3번 노선은 $[5, 0]$ 형태로 주어지며 4번 노선 $[7, 9]$를 포함하고 있습니다.

이 때, $[9, 4]$, $[5, 0]$은 표현하기 어렵기 때문에, 구간을 한 바퀴 더 있다고 생각하고(즉, 0은 10, 1은 11, 2는 12와 같도록) 바꿔주게 되면 $[9, 4]$는 $[9, 14]$, $[5, 0]$은 $[5, 10]$으로 바뀌게 됩니다.

이렇게 바꾸고 나면 4번 구간 $[7, 9]$는 3번 구간 $[5, 10]$에 포함되게 되지만, 1번과 5번 노선은 아직 포함 관계가 없습니다. 이 때, (0은 10)과 (4는 14)와 같다는 것을 이용해 $[0, 4]$를 $[10, 14]$로 바꿔주게되면 어떻게 될까요? 이는 5번 구간인 $[9, 14]$에 완전히 포함되게 됩니다. 즉 우리는 현재 구간을 2배 하고 대응되는 i번 정류장을 $N + i$번을 만드는 것으로 문제를 해결할 수 있습니다.

그렇다면, 이는 모든 구간에 대해서도 변함이 없을까요?

이러한 구간들이 생길 수 있는 모든 예시를 통해 포함관계에 문제가 생기는지 확인해봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_8_5.PNG)

위 그림과 같이 모든 경우에도 포함관계가 변하지 않는데, 이는 포함시킬 수 있는 경우가 변하지 않기 때문입니다. n을 더하기 전의 노선과 n을 더한 이후의 노선은 항상 길이가 n만큼 차이가 나지만, 노선들은 최대 길이가 n이기 때문에, 양 쪽에 n을 더하기 전의 구간과 더한 이후의 구간 둘 다에 포함 되는 경우는 존재하지 않습니다.
즉, 어떻게 존재하게 되든 새로 추가한 노선은 추가하기 전의 노선과 서로 연관되는 경우가 없어 n을 더하기 전의 노선에 일부만 포함되는 구간은 더한 이후의 노선에서 전체가 포함되는 경우는 존재하지 않습니다.

즉, 이러한 과정은 0을 걸치는 노선을 표현하는 방식으로의 역할만 하게 되므로 실제 결과에 영향을 주지 않습니다.
 
이를 통해, 우리는 선형일 때의 알고리즘을 그대로 정류장을 2N으로 늘린 상태에서의 노선을 고려하는 것으로 해결 가능합니다. 
이 때, 특정 구간의 번호가 포함되는 경우가 있는지를 확인해주기만 하면 같은 시간복잡도인 $O(NlgN)$에 문제를 풀 수 있습니다.

# [트럭 - ICPC Daejeon Nationalwide Internet Competition 2016 L번](https://www.acmicpc.net/problem/13335)

## 관찰

우리는 언제나 최대 w대의 트럭이 올라갈 수 있는 다리에서 최대 하중 L을 넘지 않도록 트럭들을 순서대로 지나게 하여 n대의 모든 트럭이 다리를 건너가는 최소 시간을 구해야합니다.

가장 쉬운 방법으로는, 모든 시간을 직접 시뮬레이션하여 해결하는 방법이 있습니다.
다리의 위치를 1부터 w, 모든 트럭들을 w + 1 이후에 위치하게 놓은 다음, 가장 앞에 있는 트럭부터 1 단위 시간씩 시뮬레이션하는 것으로 문제를 해결할 수 있습니다.

이 때, 트럭이 놓이게 되는 경우는 5가지로 분류할 수 있습니다.

- 위치만 1 감소하는 경우
- 다리 앞에 있고, 위로 올라가서 다리에 가해지는 하중이 증가하는 경우
- 다리 앞에 있으나, 다리의 최대하중이 버티지 못해 올라가지 못하는 경우
- 다리를 지나가고 있는경우
- 다리를 모두 지나 다리에 가해지는 하중이 감소하는 경우

우리는 현재 다리에 가해지고 있는 하중 S를 고려하는 것으로, 항상 2번과 3번 상황인 다리 앞의 트럭이 올라갈 수 있는지 여부를 구해줄 수 있습니다. 또한 다리의 끝, 위치 1을 지나는 트럭을 통해 하중 S를 다시 구해줄 수 있고, 나머지 트럭이 다리에 올라올 수 있는지 여부를 구해줄 수 있습니다.
그리고 4번 경우인 다리를 지나가고 있는 트럭의 경우, 항상 앞으로만 이동하여 다리를 벗어나는 것이 중요하므로, 위의 모든 경우를 고려해줄 수 있습니다.

이 때에, 우리는 매 단위시간마다 모든 트럭들의 위치를 확인하고 하중을 관리해줘야 하므로, 최악에 $O(n * 최소시간)$의 시간이 필요하게 됩니다.

## 풀이

우리는 위 관찰 과정에서 굉장히 중요한 사실을 하나 알아낼 수 있습니다. 바로 4번 경우인 ‘트럭이 다리를 지나가고 있는 경우’ 입니다. 우리는 앞서 트럭이 다리를 건너가고 있다면, 항상 앞으로만 이동하여 최대한 빠르게 다리를 벗어나, 다리에 가해지는 하중을 감소시키는 것이 중요함을 알 수 있었습니다.

이것에서 중요한 정보을 알아낼 수 있을까요? 다리를 올라온 트럭은 항상 매 초마다 앞으로 이동할 수 있고, 이는 다리를 벗어날 때까지 계속 이어지기 때문에 매 초 1단위길이를 이동하게 됩니다. 다리의 길이는 총 w이므로, 우리는 다리를 t초에 올라온 트럭이 t+w초에 다리에서 내려간다는 사실을 알 수 있습니다.

즉, 우리는 트럭이 다리에 언제 올라가지는지만 알고있다면, 트럭이 언제 다리에서 내려오는지 알 수 있습니다. 이를 통해 모든 시간을 시뮬레이션하지 않고, 트럭들이 언제 다리에 오르고 내리는지 쉽게 알아낼 수 있을까요?

위 예시를 가지고 진행해보겠습니다.

우리에겐 [7, 4, 5, 6] 4대의 트럭이 있고, 다리의 최대하중은 10, 길이는 2입니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_7_2.PNG)

현재 다리의 하중은 0이기 때문에, 첫 트럭 7은 시간 1에 바로 다리에 오를 수 있고, 앞선 관찰에 의해 1+2 = 3인 시간에 다리를 내려온다는 것을 알 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_7_3.PNG)

첫 트럭이 다리에 오른 이후, 현재 다리의 하중은 7이기 때문에, 두 번째 트럭은 다리에 오를 수 없습니다. 이 때, 우리는 다리에 오른 트럭들이 어느정도 빠져나가는 시간 이후에만 두 번째 트럭을 다리에 올릴 수 있습니다. 다리 위에 가장 앞에 서있는 트럭은 7이기 때문에, 7이 빠져나간 때를 생각해보겠습니다.

7은 시간 3에 다리에서 내려오고, 그 때의 하중은 0이 됩니다. 이제 두 번째 트럭이 오를 수 있고, 다리에 트럭이 내려감과 올라감은 동시에 일어날 수 있으므로, 시간 3에 트럭 4가 다리에 올라 하중이 4가 되며, 시간 5에 내려오게 됩니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_7_4.PNG)

현재 하중은 4이므로, 트럭 5는 다리에 올라올 수 있고, 시간 4에 바로 올라올 수 있습니다. 하중은 9가 되며 현 트럭은 시간 6에 내려오게 됩니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_7_5.PNG)

현 하중은 9이므로, 트럭 6은 다리에 올라올 수 없습니다. 다리 위 가장 앞에 있는 4가 내려와도 하중은 5가되어 불가능하고, 트럭 5까지 내려와야 올라올 수 있게 됩니다. 그러므로 트럭 5가 내려오는 시간 6에 트럭 6은 올라오게 되며, 이 트럭은 시간 8에 내려옵니다.

이제 마지막 트럭까지 확인했으므로, 마지막 트럭이 내려오는 시간 8이 최소가 됩니다.

즉, 우리는 각 트럭이 다리에 올라가는 시간, 그리고 내려가는 시간을 알고 있는 상태에서, 모든 트럭들을 앞에서부터 뒤로 관리해줄 수 있는 자료구조만 있다면, 항상 트럭이 다리에 올라가야하는지, 내려와야하는지 2가지만 확인하는 것으로 문제를 해결할 수 있습니다.

**항상 다리에 먼저 오른 트럭이 먼저 내려오기** 때문에, 우리는 **큐를 이용해서 위 트럭들을 관리**해줄 수 있습니다.

모든 트럭들은 다리에 올라갈 때 한 번, 내려갈 때 한 번씩만 확인해주기 때문에, 우리는 $O(n)$의 시간복잡도에 문제를 해결할 수 있게 됩니다.

# 코드

## 방 청소

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
int uftree[300010];
bool checkarr[300010];

void f_uftree_init(){ int i; for(i = 1; i <= n; i++) uftree[i] = i; }
int f_ances(int a){
    if(a == uftree[a]) return a; return uftree[a] = f_ances(uftree[a]);
}
void f_solve(int a, int s){
    if(!checkarr[a]){
        checkarr[a] = 1; s = f_ances(s);
        if(s != a) uftree[a] = s; printf("LADICA\n");
    }else if(!checkarr[s]){
        checkarr[s] = 1; a = f_ances(a);
        if(a != s) uftree[s] = a; printf("LADICA\n");
    }else if(checkarr[a] && !checkarr[f_ances(a)]){
        a = f_ances(a); checkarr[a] = 1; s = f_ances(s);
        if(!checkarr[s]) uftree[a] = s; printf("LADICA\n");
    }else if(checkarr[s] && !checkarr[f_ances(s)]){
        s = f_ances(s); checkarr[s] = 1; a = f_ances(a);
        if(!checkarr[a]) uftree[s] = a; printf("LADICA\n");
    }else printf("SMECE\n");
}
int main(){
    int i, a, s;
    scanf("%d %d", &m, &n);
    f_uftree_init();
    for(i = 0; i < m; i++){
        scanf("%d %d", &a, &s);
        f_solve(a, s);
    }
    return 0;
}
```

## 트럭

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, w, l;
int arr[1010], sarr[1010];
queue <int> q;

int main(){
	int i, now = 0, cnt = 0;
	scanf("%d %d %d", &n, &w, &l);
	for(i = 0; i < n; i++) scanf("%d", &arr[i]);
	i = 0;
	while(1){
		if(!q.empty() && i == sarr[q.front()]) now -= arr[q.front()], q.pop();
		if(now + arr[cnt] <= l) sarr[cnt] = i + w, now += arr[cnt], q.push(cnt), cnt++;
		if(cnt == n) break;
		i++;
	}
	printf("%d", sarr[n - 1] + 1);
	return 0;
}
```
