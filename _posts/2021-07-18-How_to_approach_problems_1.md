---
layout: post
title:  "알고리즘 문제 접근 방법"
date:   2021-07-18 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 모음

알고리즘 문제 풀이를 진행하면서, 어느정도 순간에서부터는 내가 모르는 알고리즘 및 자료구조가 필요하다는 점에서 문제 풀이의 어려움을 느끼게 됩니다. 더 발전하기 위해서 다양한 내용들을 찾아서  공부하고 이를 구현하는 방법을 익히는 과정이 필요하게 됩니다.

하지만 처음 공부할 때에 실제로 제가 가장 많이 겪었던 문제, 혹은 다른 사람들이 처음 공부를 시작 하면서 어려웠던 점들에 대해 이야기를 들을 때에 공통적으로 나왔던 부분은 바로, 알고리즘과 자료구조를 알고 있어도, 해당 문제를 어떤 알고리즘과 어떤 자료구조를 사용해야 하는지 제대로 파악하지 못하여 해결하지 못한다는 점입니다.

이러한 문제는 어떤 문제가 주어졌을 때에, 이 문제를 어떻게 파악해나아갈지, 어떻게 저근해야할지 잘 모른다는 것에서 시작합니다. 개선을 위한 가장 좋은 방법은 많은 유형의 문제들을 접해보고, 직접 해결하기 위해 시간을 들이는 것입니다. 그 과정에서 자신만의 문제 해결을 위한 접근 방법을 알게 되고, 문제를 분석하고 파악하는 과정을 익히게 되며, 특별한 알고리즘, 자료구조를 사용할 수 있는 경우들을 경험을 통해 익히는 것이 가능하게 됩니다.
그 이후로는 어떠한 문제를 보아도, '이 유형은 이러한 성질들을 만족하므로, 어떠한 알고리즘으로 접근할 수 있다'와 같은 문제에 대한 빠른 파악과 접근이 가능해집니다.

'알고리즘 문제 접근 방법'에서는 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성하려합니다.

서로 다른 난이도와 유형의 문제들의 접근 과정을 확인하면서, 어떤 방식으로 문제를 파악해나갈 수 있는지에 대한 영감을 받아갈 수 있으면 좋겠습니다.

## 유의점

많은 경우, 문제들을 해결할 때에 낮은 단계의 아이디어(시간이 오래 걸리는, 혹은 단순한)를 개선하는 방식으로 해결하는 것이 가능합니다.
하지만 모든 경우가 아이디어 개선을 통해 해결할 수 있지는 않습니다. 특정 문제 상황에서만 적용되는 성질을 파악해야할 수도 있으며, 아예 기본적인 아이디어에서  다른 방향으로 접근해야만 시간복잡도를 개선할 수 있거나 더 쉽게 문제를 해결할 수 있는 경우들도 존재합니다.

이러한 경우들이 존재하기 때문에, 문제를 접근할 때에는 특정 성질이나 아이디어에 꽂혀 유연한 사고를 멈추는 일을 조심해야합니다. 이전에 문제를 해결한 경험들이 이후의 문제 풀이들을 빠르게 진행하는 데에 도움을 줄 수는 있으나, 특별한 조건이나 성질을 놓치게 만들 수도 있스니다.

문제를 해결하기 위해서는 항상 해당 문제를 접근하는 과정에서 내가 놓친 부분이 없는지 끊임없이 고민해야합니다.

## [다리 - Daejeon Nationalwide Internet Competition 2012 A번](https://www.acmicpc.net/problem/9006)

### 관찰

우리는 특별한 방법이 떠오르지 않을 때에, 문제에서 요구하는 조건을 그대로 구현하는 것으로 가장 쉽게 문제를 해결할 수 있습니다. 물론 효율적임은 보장이 되진 않지만, 문제를 파악하기에 어느정도 좋은 접근방법입니다.

문제에서 요구하는 것은 왼쪽 n개의 집에서 오른쪽 m개의 집으로 h 높이에 있는 다리를 이용하여 이동할 때에 걸리는 모든 거리의 합을 최소로 시키는 것입니다.

즉, 이를 그대로 구현하여, 가능한 모든 높이에 다리를 설치해보고, 왼쪽 집에서 오른쪽 집으로 이동하는 거리들의 합을 모두 구해본 다음, 그 때의 최솟값을 가지는 h를 출력하는 것으로 문제를 해결할 수 있습니다.

모든 집들의 쌍은 총 n * m개 존재하고, 가능한 모든 높이의 경우의 수를 w라고 했을 때, 모든 w개의 위치에 다리를 놓아보고 n * m쌍의 거리의 합을 구함으로써, 총 O(nmw)에 문제를 해결할 수 있습니다.

우리는 현재 이 상태에서 조금 더 효율적으로 문제를 해결하고 싶습니다. 문제에서 주어진 모든 쌍의 거리의 합을 구하는 부분을 살펴보겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_1_1.PNG)

여기에서, 하나의 ai와 bj 쌍에 대해 거리를 계산하는 식을 보면, |ai - h| + 2 + |h - bj|가 된다는 것을 알 수 있습니다. 그렇다면 이 식을 각각 |ai - h|, 2, |h - bj|로 나누어 보겠습니다.

이 때, 2를 더하는 경우는 i와 j에 상관없이 항상 2만 더한다는 것을 알 수 있습니다. 그렇다면, 이는 모든 쌍에 대해서 몇 번 일어나게 될까요? 우리가 가진 집의 모든 쌍은 총 n * m개가 존재하므로, 우리는 2를 n * m번 더할 것이라는 것을 알 수 있습니다.

하나의 ai에 대해서, |ai - h|는 j에 상관없이 항상 똑같은 값을 가집니다. 즉, 우리는 특별한 i에 대해 |ai - h|가 m번 더해질 것이란 사실을 알 수 있고, 마찬가지로 |h - bj| 또한 i에 상관없이 똑같은 값을 가지므로, n번 더해질 것이란 것을 알 수 있습니다.

즉, 이를 이용하여 2는 i, j 상관없이 총 n * m번, |ai - h|는 m번, |h - bj|는 n번 더해지게 되므로, 우리는 주어진 식을 다음과 같이 바꿀 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_1_2.PNG)

즉, 우리는 모든 n, m 쌍에 대해 계산하는 것이 아니라, 1 ~ n까지의 i에 대해서 |ai - h| * m을, 1 ~ m까지의 j에 대해서 |h - bj| * n을 계산해주면 되므로, 합을 계산하는데 총 O(n+m)이 걸리고, 우리는 시간복잡도를 O(nmw)에서 O(w * (n + m))으로 개선시킬 수 있습니다.

### 풀이

이제 우리는 변형된 식을 최소로 만드는 다리의 위치를 찾아주는 것으로 문제를 해결할 수 있습니다. 여기에서 어떤 규칙으로 다리의 최소 위치를 찾는지 바로 감을 잡는다면 문제가 없지만, 어떤 경우 우리는 그 규칙을 찾기 어려울 수 있습니다.
이 때엔, 직접 예제를 손수 계산해보는 것으로 규칙을 찾을 수도 있어, 실제로 해보는 것이 좋습니다.

앞선 예시인 왼쪽 강의 집이 각각 30, 5, -16에 위치하고, 오른쪽 강의 집이 25, -5, -10, -20인 경우를 살펴봅시다.

우리가 30보다 높은 위치나 -20보다 낮은 위치에 다리를 놓을 필요가 있을까요?

우리가 정답으로 계산하는 i와 j에 대한 식은 각각 |ai - h|와 |h - bj|입니다.
여기에서 h가 30일 때에서보다 더 높아지거나 -20보다 더 낮아질때를 생각해보겠습니다. 우리는 절대값을 최소화하기 위해서 집과 다리의 위치의 차를 가장 작게 만들어야합니다. 하지만, 집들의 위치보다 더 높거나 낮은 곳에 다리를 위치하게 되면, 모든 |ai - h|와 |h - bj|가 더 커지게 됩니다. 즉, 우리는 항상 집들의 최소와 최대 위치 사이에 다리를 놓아야함을 알 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_1_3.PNG)

빨간 다리를 위치하게 되면, 모든 집들이 다 파란색 다리에 비해 노란색만큼 더 이동해야함

이제 가장 높은 30의 위치에 다리를 놓는 것으로부터 생각해보겠습니다. (30, 5, -16), (25, -5, -10, -20)의 집들은 각각 절대값이 (0, 25, 46), (5, 35, 45, 50)이 됩니다. 이 때, 아래로 1의 위치만큼 이동했을 때를 생각해보겠습니다. 그 경우 절대값은 각각 (1, 24, 45), (4, 34, 44, 49)가 됩니다. 어떤 변화를 관찰할 수 있을까요?

이 때, 우리는 30에 위치한 집 빼고는 절대값이 모두 1씩 줄어들었다는 것을 관찰할 수 있습니다. 이를 살펴보겠습니다.

다른 집들은 모두 30보다 낮은 위치에 있었기 때문에, 다리에서 집의 위치를 뺀 값이 모두 양수였습니다. 즉, 다리의 위치가 1 낮아져도 값들이 0 이상임은 보장되고, 결국 값들이 모두 1 줄어든다는 결과를 낳게 됩니다.

(25, 46, 5, 35, 45, 50) -> (24, 45, 4, 34, 44, 49)

하지만 30의 집은 그 차가 0이었기 때문에, 다리가 낮아지면 음수가 되어 값은 더 커지게 됩니다.

혹시 여기에서 한 규칙을 발견할 수 있을까요?

우리는 여기에서 |다리 - 집| 의 값을 보면서 규칙을 알아볼 수 있습니다.

- 다리 - 집 > 0 인 경우, 다리가 1 낮아지면 값도 1 줄어들고, 1 높아지면 값이 1 증가함
- 다리 - 집 = 0 인 경우, 다리가 1 낮아져도 높아져도 값이 1 증가함
- 다리 - 집 < 0 인 경우, 다리가 1 낮아지면 값이 1 증가하고, 1 낮아지면 값이 1 감소함

즉, 우리는 |다리 - 집|이 0보다 큰 경우, 0인 경우, 0보다 작은 경우로 나누어 케이스를 나눠줄 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_1_4.PNG)

이 때, 우리는 방향성을 알아보기 편하게 하기 위해서 다리의 위치를 항상 1씩 감소하면서 살펴보겠습니다.
이 때, 거리의 합은 왼쪽 집과 오른쪽 집에대해 각각 |다리 - 집| * m, |다리 - 집| * n이므로, 우리는 다리의 위치가 1 감소할 때 거리의 합의 증감은 다음과 같이 살펴볼 수 있습니다.

- 왼쪽 집에서 다리 - 집 > 0인 집이 p개, 오른쪽 집에서 다리 - 집 > 0인 집이 q개라면
합은 (n - p) * m + (m - q) * n - (p * m + q * n) = (n - 2p) * m + (m - 2q) * n 만큼 증가함

초기의 p와 q는 각각 n, m인 상태로 볼 수 있고, 다리가 1씩 감소할수록 p나 q는 항상 감소하게 되므로, 우리는 어느 위치에서 (n - 2p) * m + (m - 2q) * n > 0이 되는 위치를 찾을 수 있을 것입니다. 즉, 그 이전까지 된다면 거리의 합이 최소가 되는 경우가 됩니다.

이제 다리의 위치가 감소하다가, (n - 2p) * m + (m - 2q) * n > 0인 위치를 찾으면 그 이전이 바로 답이 됨을 알 수 있습니다. 하지만 아직도 우리는 다리를 1씩 감소하며 답을 찾고 있습니다. 혹시 이를 해결할 방법이 있을가요?

이는 p와 q가 각각 언제 감소하는지를 가지고 살펴볼 수 있습니다.

만약 다리를 아래로 1만큼 내리더라도, 그 위치에 집이 있지 않다고 해봅시다. 이 때, 다리 - 집 > 0을 만족하는 p, q가 감소하는 경우가 있을까요? 정답은 ‘없다’ 입니다.

왜냐하면 다리를 1만큼 내려도 그 위치에 아무런 집이 없다면, 지금 현재 다리의 이상 위치에 있는 집들은 항상 ‘다리 - 집 <= 0’을 만족하는 상태이고, 다리 아래에 있는 집들, 즉,  ‘다리 - 집 > 0’인 집들은 사실 ‘다리 - 집 > 1’을 만족하는 상태일 수 밖에 없기 때문입니다.

즉, 현재 ‘다리 - 집 > 1’인 집들은 1씩 줄어도 ‘다리 - 집 > 0’을 만족하므로, p와 q는 그대로가 됩니다.

결국 p와 q가 변하기 위해서는 1 감소할 때 바로 집이 있는 위치가 되어야합니다. 또한 이를 다르게 표현한다면 ‘집이 있는 위치만이 p와 q의 변화가 생긴다’를 알 수 있습니다.

결국 우리는 모든 위치를 고려하는 것이 아니라, n + m개의 집이 있는 위치만 고려하여 답을 찾아줄 수 있고, 이 중 집의 위치가 높은 곳부터 계산하는 것으로 문제를 해결할 수 있습니다.

집들의 위치를 내림차순으로 정렬하는데 O((n+m)lg(n+m)), 좌표를 하나씩 내리는, 총 O(n + m)의 시간복잡도로, 최종적으로 정렬하는데 걸리는 시간복잡도로 문제를 해결할 수 있습니다.

ps. 입력이 정렬되어 들어온다면 우리는 조건을 만족하는 위치를 이분탐색으로 찾을 수 있습니다.
또한 입력이 정렬되지 않은 상태로 들어온다면 우리는 삼분탐색을 이용한 O((n + m)lgw)에 문제를 해결할 수도 있습니다

# 코드

## 막대기_스택

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
stack <int> st;

int main(){
  int i, a;
  scanf("%d", &n);
  for(i = 0; i < n; i++){
    scanf("%d", &a);
    while(!st.empty() && st.top() <= a) st.pop();
    st.push(a);
  }
  printf("%d", st.size());
  return 0;
}
```

## 막대기_번외풀이

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, res, max1;
int arr[100010];

int main(){
	int i;
	scanf("%d", &n);
	for(i = 0; i < n; i++) scanf("%d", &arr[i]);
	for(i = n - 1; i >= 0; i--) if(arr[i] > max1) max1 = arr[i], res++;
	printf("%d", res);
	return 0;
}
```

## 쇠막대기_열린 괄호의 수만 유지

```cpp
#include <bits/stdc++.h>
using namespace std;

int res,cnt,n;
char arr[100010];

int main(){
    int i;
    scanf("%s",arr);
    n=strlen(arr);
    for(i=0;i<n-1;i++){
        if(arr[i]!=arr[i+1] && arr[i]=='('){
            res+=cnt; i++;
        }
        else if(arr[i]=='(')cnt++;
        else{
            res++; cnt--;
        }
    }res+=cnt;
    printf("%d",res);
}
```
