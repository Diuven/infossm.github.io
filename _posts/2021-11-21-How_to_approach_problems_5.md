---
layout: post
title:  "알고리즘 문제 접근 과정 5"
date:   2021-11-21 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 5

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [두 배열의 합 - KOI 2001 고등부 1번](https://www.acmicpc.net/problem/2143)

## 관찰

우리가 생각해볼 수 있는 가장 쉬운 방법은 무엇이 있을까요?
아마 문제에서 나온 방법을 그대로 사용하는 것이 가장 편한 방법일 것입니다. 우리가 만들 수 있는 A의 부 배열과 B의 부 배열의 모든 가능한 조합을 고려하여, 그 중 합이 T가 되는 경우의 수를 세는 것으로 문제를 해결할 수 있습니다. 이 과정에서 A, B에 대한 부배열 쌍은 각각 약 $N^2$, $M^2$개 존재하게 되어, 실질적으로 만들 수 있는 가능한 조합은 대략 $(NM)^4$개가 존재하게 됩니다. 이를 단순하게 부 배열의 범위가 정해졌을 때, 그 사이에 있는 모든 수를 더하는 방법으로 계산하게 되면 너무 오랜 시간인 $O((NM)^3)$이 걸립니다. 하지만 누적합을 이용해서 범위 (l, r) 사이에 있는 수들의 합을 $O(1)$에 해결하는 아이디어를 사용한다면 모든 쌍을 비교하는 과정을 $O((NM)^2)$에 해결하게 됩니다.
배열의 최대 크기가 1000으로 작기 때문에 모든 부 배열을 구하는 것은 가능하지만, $(NM)^2$의 모든 경우의 수를 찾는 것은 너무 오랜 시간이 걸리게 됩니다.

## 풀이

우리가 A 배열의 특정 부 배열의 값이 a임을 알고 있다고 합시다. 그렇다면, B 배열의 어떤 부 배열의 합 b가, a와 합쳐져서 T가 될 수 있을까요?
이 때, 항상 $T = a + b$를 만족해야하기 때문에 $b = T - a$인 부 배열들만이 T를 만들 수 있게 됩니다.
즉, 우리는 A 배열에 있는 $N^2$ 개의 부 배열들에 대해 각각, $T - a_{i}$ 를 만족하는 B의 부 배열의 개수를 세주는 것으로 문제를 해결할 수 있습니다.
그렇다면, $T - a_{i}$ 를 만족하는 부 배열이 존재하는지, 그리고 그 경우의 수는 몇 가지가 있는지 어떻게 알 수 있을까요?

A, B의 $N^2$ 개의 부 배열들을 각 부 배열의 합을 기준으로 정렬을 해줍시다. 이 때, 우리는 항상 다음 두 조건을 만족하게 됩니다.

- $a_{i} <= a_{j} , i < j$	즉, a는 단조증가
- $b_{i} <= b_{j} , i < j$	즉, b는 단조증가

즉, 우리가 i가 1부터 증가하는 순서대로 보게 된다면 항상 $a_{i}$는 증가하게 되고, j를 $N^2$부터 감소하는 순서로 보게 된다면 항상 $b_{j}$는 감소하게 됩니다. 그렇다면, 어떤 $a_{i}$에 대해 $b_{j}$의 합이 T가 된다고 해봅시다.

- $a_{i} + b_{j} = T$

그렇다면 이 때, $a_{i+1}$에 대해 합이 T가 될 수 있는 원소들은 어디에 존재할 수 있을까요?

앞선 a가 단조증가한다는 조건을 이용하면 모든 i에 대해 $a_{i} <= a_{i+1}$을 만족합니다. 즉,

- $a_{i} + b_{j} = T	=>	a_{i+1} + b_{j} >= T$

를 만족하게 되고, b는 항상 값이 단조증가함을 이용하면 $a_{i+1} + b_{k} = T$를 만족할 가능성이 있는 k들은 $k <= j$ 인 k들만 해당됨을 알 수 있습니다.

결국 우리는 앞선 $a_{i} + b_{j} <= T$를 만족하는 j의 최댓값부터 $a_{i+1} + b_{j} >= T$ 를 만족할 때까지 줄여가면서 그 사이에 $a_{i+1} + b_{j} = T$를 만족하는 경우의 수를 모두 세주면 됩니다.

앞선 예시를 통해 더 자세히 알아봅시다.

A = {1, 3, 1, 2}, B = {1, 3, 2}, T = 5 이므로 이를 부배열의 합을 정렬하여 나타내면



가 됩니다. 이 때, $a_{1}은 $b_{6}, b_{5}$와 합해도 5를 넘어가기 때문에, 이를 j를 줄여 $b_{4}$에서 합이 5가 만족하게 됩니다.





그러면 이후 $a_{2}$는 아무리 커도 j = 4인 때를 넘어가지 않게 되고, j = 4부터 만족할 때까지 j를 줄여나가면, j = 4일 때에만 답을 만족하게 됩니다.




$a_{3}$ 또한 아무리 커도 j = 4인 때를 넘어가지 않고, j = 4를 만족하지 않으므로 j를 줄이게 되면 j = 3일 때 답이 됨을 알 수 있습니다.





($a_{i} = a_{i+1}$일 수 있는 가능성 때문에, j를 바로 줄이지 않고 j = 4와 한 번 비교하게 됩니다)

하지만 우리는 아직 해결하지 못한 문제가 있습니다. 이를 이용해 모든 경우의 수를 다 보지 않고, 실제로 존재하는 쌍들만 확인하여 문제를 해결할 수 있어서, 만약 실제 답이 $N_{2}$보다 작다면(혹은 중복된 부 배열합이 없다면) 문제없이 해결할 수 있지만, 모든 a와 b가 0이고, T 또한 0인 문제가 나온다면, 매 순간 l의 범위는 b의 부 배열의 수 전체가 되어 $N_{4}$가 걸릴 수도 있습니다. 우리는 모든 쌍을 하나씩 세는 것이 아닌, 여러개씩 세서 더 빠르게 만드는 방법을 구해야합니다.

만약 [$a_{i}, a_{i+c}$] 사이의 원소들이 모두 같은 값이라면 어떻게 될까요? 특정 $a_{i}에 대해 [$b_{j}, b_{j+d}$] 사이의 원소들의 합이 T를 만족한다면, $a_{i+1}$ 부터 $a_{i+c}$까지의 원소들 또한 [$b_{j}, b_{j+d}$]에 대해 합이 T를 만족할 것입니다. 그렇다면, 특정 $a_{i}$와 같은 값들의 수를 세주고, 이에 해당하는 $b_{j}$의 값들을 세어 두 수의 곱을 구하게 된다면, 우리는 바로 $a_{i+c+1}$번부터 볼 수 있고, $b_{j-1}$부터 보기만 하면 됩니다. 그렇다면 과연 이 방법으로 시간복잡도를 크게 바꿀 수 있을까요?




1을 한 번에 처리하는 것으로, 이후에 나오는 2는 절대로 1과 매치됐던 4 이상의 값들과는 합이 T가 될 수 없음을 알 수 있어, 바로 4보다 작은 값인 3과의 비교를 시작합니다.





정답은 **시간복잡도를 바꿀 수 있다** 입니다. 이처럼 여러개의 연속된 구간들을 한 번에 볼 수 있게 된다면, 우리는 i를 항상 증가하는 방향으로만 보고, j도 연속된 구간을 구하고 나면, 다음번 $a_{i}$는 증가할 것이기 때문에 $b_{j}$ 또한 항상 이전 구간의 원소와 합하면 값이 T보다 커진다는 사실을 알 수가 있게 됩니다. 즉, j 또한 항상 감소하는 방향으로만 봐야하기 때문에, 우리는 a의 각 원소를 한 번씩만, b의 각 원소 또한 한 번씩만 확인하게 되어, 연속된 구간을 한 번에 처리하는 방법만으로, 답을 구하는 데에는 $O(N^{2} + M^{2})$의 시간만이 걸리게 됩니다.

결국 시간복잡도는 $N^2$, $M^2$개의 배열을 정렬하는데 걸리는 시간인 $O(N^{2}lgN + M^{2}lgM)$이 되어 문제를 빠르게 해결할 수 있습니다.

## 번외 풀이

앞서 우리는 A의 i를 증가하는 방향으로, B의 j를 감소하는 방향으로 문제를 풀었습니다. 우리는 이를 다른 방법을 사용하는 것으로 조금 더 간단하게 해결할 수도 있습니다.

앞선 방법과 동일하게 B의 모든 부 배열의 합들을 만들어 둔 이후, 이를 오름차순으로 정렬해두었다고 생각해봅시다. 이 때, 어떠한 $a_{i}$에 대해서 합이 T가 되는 값들을 빠르게 찾는 방법이 있을까요?
우리는 특별한 방법을 사용하여, 특정한 $a_{i}$에 대해 합이 T가 되도록 하는 $b_{j}$의 경우, 항상 $b_{j} = T - a_{i}$를 만족해야 한다는 조건을 살펴본 적이 있습니다. 즉, 우리는 해당하는 $b_{j}$의 수가 몇 개인지 빠르게 구하는 방법을 알고 있다면 문제를 해결할 수 있게 됩니다.
이 때, 우리는 B 배열이 항상 정렬되어있다는 것을 사용해볼 수 있습니다. 위 조건을 만족하는 $b_{j}$들이 존재한다면 이들은 B 배열 내에서 연속해서 존재하게 됩니다. 그리고 이러한 b의 범위 오른쪽은 항상 $b_{j}$보다 더 큰 값이 존재할 것이고, 이보다 왼쪽에 있는 값들은 항상 $b_{j}$보다 더 작은 값들이 존재할 것입니다. 즉, 이것을 통해서 $b_{j}$가 존재하는 최대 위치와 최소 위치를 구할 수 있다면, 그 사이의 범위에 들어있는 부 배열의 갯수를 빠르게 구할 수 있지 않을까요?
어떠한 $a_{i}$에 대해서, $b_{j} <= T - a_{i}$가 되는 j의 최댓값을 이분탐색을 이용해 구하고, $b_{j} >= T - a_{i}$를 만족하는 j의 최솟값을 이분탐색을 이용해 구해줍니다. 이 값들을 각각 c, d라 하면 항상 [d, c] 에 있는 원소들이 실제 답이 되는 b의 범위가 됩니다. 즉, 하나의 a에 대해 해당하는 b의 범위를 두 번의 이분 탐색을 사용해서 구할 수 있다는 것입니다.

이러한 이분탐색에는 $O(lgM)$ 만큼의 시간이 걸리기 때문에, 우리는 모든 a에 대해 중복을 처리하지 않고, 이분 탐색을 적용해 $O((N^{2}+M^{2})lgM))$의 시간복잡도로 문제를 해결할 수 있습니다.
이는 답을 구하는데 기존의 풀이보다는 조금 더 느리게 동작하지만, 시간복잡도 자체는 정렬하는 시간이 지배한다는 점 때문에 사용해도 같은 시간복잡도를 얻게 됩니다.
(만약 부 배열들이 정렬되어 있는 상태라면, 기존의 방법은 O(N^{2}+M^{2})에 해결할 수 있으며, 번외 풀이는 이분 탐색 과정에서 시간이 더 필요하기 때문에 $O(N^{2}lgM))$의 시간이 필요합니다.)

이렇게 정렬된 배열 내에서 해당 원소의 최대 위치와 최소 위치를 찾는 이분 탐색은 STL로 구현되어 있습니다.
최소 위치에 해당하는 값의 주소는 algorithm header에 들어있는 함수 std::lower_bound()를, 최대 위치는 std::upper_bound()를 이용하여 쉽게 구할 수 있습니다.

# [사발 뒤집기 - USACO 2006 January Bronze 3번](http://jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=3034&sca=9040)

## 관찰

우리가 어떤 그릇을 두 번 뒤집는다면 어떻게 될까요? 한 번 뒤집었을 때엔 우리가 뒤집은 그릇과 그 양 옆의 그릇이 뒤집어지지만, 두 번 뒤집었을 때는 그 그릇들이 모두 2번씩 뒤집어지기 때문에, 결국 처음 상태와 같아지게 됩니다. 이는 아예 우리가 택한 그릇들 뒤집지 않는 것과 같은 결과를 만들어내므로, 우리는 두 번 이상 같은 그릇을 뒤집는 것은 항상 좋지 않다는 것을 알 수 있습니다.

그렇다면 결국 모든 그릇은 한 번 뒤집어지거나 한 번도 뒤집어지지 않는, 2개의 상태만으로도 나타낼 수 있게 됩니다.

이를 이용해 가장 쉽게 생각해볼 수 있는 방법은, 모든 그릇들을 각각 뒤집어보는 것과 뒤집지 않는 것, $2^N$개의 상태를 모두 시뮬레이션 하는 것으로, 최종적으로 모든 그릇이 0의 상태가 되었는지 확인한다면, 그릇을 뒤집는지 여부 $2^N$, 각 그릇들이 0인지 확인하는 것 N번으로, 총 $O(N2^N)$에 문제를 해결할 수 있습니다.
이를 이용해 작은 크기의 문제는 해결할 수 있지만, N이 커진다면 시간복잡도는 굉장히 커지므로, 우리는 더 좋은 방법을 생각해야합니다.

## 풀이

우리가 모든 그릇들을 다 0인 상태로 만들려고 한다면, 1번 그릇 또한 우리가 모든 그릇들을 뒤집고 났을 때 항상 0인 상태로 존재해야 합니다. 그렇다면, 우리는 어떤 그릇들을 뒤집기로 정해놓았을 때, 그 뒤집기가 1번 그릇의 상태를 0으로 만들게 되는지를 모든 뒤집기를 수행하지 않고도 알 수 있을까요?

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_4_8.PNG)

만약 그릇들이 1 0 0 0 0 0 0 0 과 같이 1번 그릇만 뒤집혀 있는 상태로 놓여있다고 합시다. 이 때 3번 그릇을 뒤집는다면 결과는 어떻게 될까요?

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_4_9.PNG)

3번 그릇을 뒤집으면 2, 3, 4번 그릇이 모두 뒤집히므로 결과는 1 1 1 1 0 0 0 0 이 되게 되어 1번 그릇은 뒤집히지 않고, 그대로 1인 상태로 놓이게 됩니다.
그렇다면, 4, 5, 6, 7, 8번을 아무렇게나 뒤집는 것으로, 1번 그릇을 0으로 만들 수 있을까요?

실제로 해본다면, 절대 1번 그릇을 0으로 만들 수 없다는 것을 알 수 있습니다. 모든 그릇들은 항상 뒤집힐 때, 자신의 양 옆의 그릇을 추가로 뒤집게 되므로, 3번 이상의 그릇들은 최대 2번 그릇까지 밖에 같이 뒤집지 못합니다.

결국 1번 그릇을 뒤집을 수 있는 경우는, 1번 그릇 혹은 그 양 옆의 그릇을 뒤집는 경우 뿐이므로, 1번 그릇을 뒤집거나, 2번 그릇을 뒤집거나, 1, 2번 그릇 모두 뒤집는 경우, 이 세가지 경우만이 1번 그릇에 영향을 줄 수 있다는 것을 알 수 있습니다.

이를 통해, 만약 1번 그릇이 0인 상태라면, 1, 2번 그릇을 뒤집지 않거나, 1, 2번 그릇을 모두 뒤집는 2가지 경우만 가능하고, 1번 그릇이 1인 상태라면 1번 그릇을 뒤집거나, 2번 그릇만 뒤집는 2가지 경우가 있음을 알 수 있습니다.

우리가 1, 2번 그릇을 원하는 대로 뒤집는 것을 통해 1번 그릇을 0인 상태로 만들고 나면, 나머지 그릇들은 어떻게 0으로 만들 수 있을까요?

1 0 0 0 0 0 0 0 에서 1번 그릇을 뒤집고, 2번 그릇을 뒤집지 않는 것으로 1번 그릇을 0으로 만들었을 때를 생각해봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_4_10.PNG)

이 때에 이미 1, 2번 그릇은 뒤집거나 뒤집지 않는 것을 결정했으므로, 우리는 3~8번의 그릇들만 추가로 뒤집을 수 있게 됩니다. 하지만, 사실 1, 2번을 뒤집어 1번을 0으로 만들어 놓는다면, **3번부터 8번까지의 그릇들은 뒤집는 여부가 항상 유일하게 결정**됩니다.

이를 예시를 보면서 알아보겠습니다. 1번 그릇을 0으로 만들었으므로, 2번 그릇을 생각해봅시다. 2번 그릇은 현재 뒤집혀 있는 상태이지만, 1, 2번 그릇들은 뒤집을 때 1번 그릇에 영향을 주므로, 이를 뒤집어 2번을 0으로 만들면 안됩니다. 즉, 남아있는 뒤집을 수 있는 그릇들 중, **2번 그릇에 영향을 줄 수 있는 유일한 그릇은, 2번 그릇의 오른쪽에 있는 3번 그릇**이 됩니다. 현재 2번이 뒤집혀있으므로, 3번 그릇은 항상 뒤집을 수 밖에 없게 되고, 상태가 변화하게 됩니다.

1, 2번이 모두 0이 되게 되면, 3번 그릇을 생각해야 합니다. 만약 3번 그릇이 0인 상태라면, 이를 뒤집으면 안되므로 4번 그릇은 뒤집지 말아야하고, 1인 상태라면 4번 그릇을 뒤집어야합니다.
즉, 1번 그릇을 0인 상태로 만들게 되면, 이후 2번 그릇부터는 순차적으로 진행하면서, **현재 보고 있는 그릇의 뒤집힌 상태에 따라 오른쪽 그릇을 뒤집어야하는지 여부가 무조건 결정**됩니다. 이를 통해 우리는 3, 4, …, N - 1번 그릇까지 보면서 오른쪽 그릇들을 뒤집을지 결정해줄 수 있고, 더 이상 뒤집을 수 있는 그릇이 없는 N번 그릇에 대해, 0이라면 상태를 만들 수 있고, 그렇지 않다면 만들 수 없다는 것을 알 수 있습니다.

1번 그릇을 0으로 만드는 경우는 어떠한 상태에서도 항상 2개 존재하므로, 각 두 경우에 대해 모두 해보는 것으로 모든 그릇을 0으로 만들 수 있는지 확인해줄 수 있습니다.

이는 결국 1, 2번 그릇을 뒤집고 나면 3번부터 N번까지는 순차적으로 확인하게 되므로, 가능한 경우 중에 더 적게 그릇을 뒤집은 경우가 답이 되어 $O(N)$에 문제를 해결 할 수 있습니다.

# 코드

## 줄 세우기

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, res;
int arr[1000010], dp[1000010];

int main(){
	int i;
	scanf("%d", &n);
	for(i = 0; i < n; i++){
		scanf("%d", &arr[i]);
		dp[arr[i]] = dp[arr[i] - 1] + 1;
		res = max(res, dp[arr[i]]);
	}
	printf("%d", n - res);
	return 0;
}
```

## 사발 뒤집기

```cpp
#include <bits/stdc++.h>
#define n 20
using namespace std;

int arr[30], arr2[30], res = 1e9;

int main(){
	int i, now = 0;
	for(i = 1; i <= n; i++) scanf("%d", &arr[i]), arr2[i] = arr[i];
	for(i = 1; i < n; i++){
		if(arr[i]){
			arr[i] ^= 1;
			arr[i + 1] ^= 1;
			arr[i + 2] ^= 1;
			now++;
		}
	}
	if(!arr[n]) res = min(res, now);
	now = 1;
	arr2[1] ^= 1;
	arr2[2] ^= 1;
	for(i = 1; i < n; i++){
		if(arr2[i]){
			arr2[i] ^= 1;
			arr2[i + 1] ^= 1;
			arr2[i + 2] ^= 1;
			now++;
		}
	}
	if(!arr2[n]) res = min(res, now);
	printf("%d", res);
	return 0;
}
```

