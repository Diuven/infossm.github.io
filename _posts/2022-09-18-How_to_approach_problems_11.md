---
layout: post
title:  "알고리즘 문제 접근 과정 11"
date:   2022-09-18 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 11

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [Two Machines - ICPC 2019 Seoul Nationalwide Internet Competition L번](https://www.acmicpc.net/problem/17528)

## 관찰

주어진 문제를 간단히 본다면, 머신 A와 머신 B에서 각각 작업에 걸리는 시간이 다른 N개의 일을, A와 B에 적절히 할당하여 동시에 일을 진행하고, 일처리가 끝나는 시간을 최소화 시키는 문제입니다. 어떤 일은 A에서 굉장히 빨리 처리할 수 있고, 어떤 일은 B에서 빨리 처리할 수 있기 때문에, 일을 잘못 배정하면 걸리는 시간이 천차만별이 될 수 있습니다. 그렇다면, 어떻게 스케줄링해야 시간을 줄일 수 있을까요?

가장 먼저 드는 생각은, 작업들 중에서 가장 적은 시간이 걸리는 일을, 그 때 시간에 해당하는 머신에 할당해주는 것일 겁니다. (250, 1)의 시간이 걸리는 일이 4개가 있다고 한다면, 하나도 A에 할당하지 않고, B에 모두 할당해주는 것이 좋으니, 어떻게 생각하면 어느정도 좋은 답을 구해줄 수 있을 것 같습니다. 하지만 이는 위의 일이 300개 있다고 했을 때, 모든 일이 B에 배정될 것이기 때문에, 300의 시간이 걸리게 되지만, 하나의 일은 A에 할당하게 되면 299의 시간이 걸려 조금 더 줄어들어 답을 구할 수 없음을 알 수 있습니다.

그렇다면, 조금 더 좋은 방법을 생각해볼까요?

우리가 만약에 바로 다음번에 머신에 할당해야하는 일이 무엇인지 모르는 상황이라면, 어떤 방법으로 작업을 머신에 할당해줄 수 있을까요?
이를 해결하기 위해 생각해볼 수 있는 방법으로는 그 일을 A에도 할당해 보고, B에도 할당해 본 다음 가장 적은 시간이 걸리는 할당을 선택해 주는 것입니다. 현재 할당되어있는 머신에 대해서는, 현재 작업을 A에 할당하거나, B에 할당하는 항상 두 가지만 존재하기 때문에, 더 좋은 쪽에 할당해놓아 A와 B가 걸리는 시간이 비슷하게 놓는 것이 가능합니다.

이 방법을 이용하면 위의 두 예시도 실제 답을 구해줄 수 있습니다. 그리고 매 순간 두 기계의  동작시간의 최대가 작도록 할당해놓는다면, 매 순간 A와 B가 걸리는 시간의 차는 아무리 커도 (한 작업에 걸리는 가장 큰 시간)보다 작게 됩니다. 만약 A와 B에 할당된 시간의 차가 작업에 걸리는 가장 큰 시간보다 크다면, 현재와 최대 시간이 같도록 하는 상태에서, 다른 한 쪽에 완전히 포함시킬 수 있기 때문입니다.


![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_1.PNG)
만약 할당된 시간과 작업이 위와 같이 주어진다면
![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_2.PNG)

위 작업을 B에 할당시켜주는 것이 좋다

이를 굉장히 많이 반복하다보면, A와 B에 걸리는 작업이 거의 절반씩 나눠지는 상태가 될 것이므로, ‘보통 좋은 상태’를 만들 수 있습니다.

하지만 우리에게 이미 작업이 주어졌을 경우에, 이는 ‘어느정도 좋은 것이 보장되는 답’을 구할 수는 있지만, ‘최적의 답’을 구하지는 못할 수 있습니다.

예를 들어, (1, 1)이 2개 있고, (20, 19)이 주어진다면, 위 방법으로는 A와 B에 1을 하나씩 할당한 이후, B에 19를 할당하여 총 20의 시간이 걸리게 됩니다.
하지만 만약 두 일을 모두 A에 할당하고, 세 번째 일만 B에 할당한다면 총 19의 시간이 걸려 더 좋은 답을 얻을 수 있습니다.

이처럼 좋은 방법을 쓰고, 실제 답과의 차이가 얼마 안나는 좋은 방법이 있더라도, 최적의 할당을 해주는 일은 쉽지가 않아, 실제로 할 수 있는 할당들 중 가장 좋은 최적을 찾는 방법을 사용해야 합니다.

그렇다면, 어떻게 실제 할 수 있는 할당들을 해볼 수 있는지 알아보겠습니다.

## 풀이

가장 쉬운 방법으로는 실제 할 수 있는 모든 할당을 해보는 것입니다. 각 작업은 각각 A, B에 할당하는 두 가지 방법이 있기 때문에 우리는 2^n 가지의 모든 매칭을 해볼 수 있습니다. 이를 실제로 각 일에 대해 걸리는 비용을 합하는 과정까지 구현하여, 그 중 최솟값을 구해줄 수 있고, 총 O(N*2^N)에 문제를 해결할 수 있습니다.

실제로 위 방법은 최적의 답을 언제나 찾을 수 있다는 장점이 있습니다만, 작업의 수가 커질수록 정말 오래걸리는 단점이 있습니다.

즉, 우리는 할 수 있는 모든 것을 해보는 것으로는 답을 구하는데 무리가 있습니다. 이를 해결하기 위해, 우리는 ‘보지 않아도 되는 것들을 제외하고’ 고려할 필요가 있습니다.

이를 구현하기 위해서는 어떤 방법이 필요할까요? 우리가 앞서 이와 비슷한 문제들을 풀어본 적이 있습니다. 이를 해결하기 위해 동적계획법을 이용해봅시다.

만약, 현재 i개의 작업을 보고 있을 때, 머신 A에 j만큼의 시간이 배정되어 있고, B에는 k만큼의 시간이 배정되어있다면, (a, b)의 시간이 걸리는 i+1번 작업을 어떻게 할당해 줄 수 있을까요?

이 때에, i+1번 작업을 A에 할당한다면, i+1개의 작업에 대해 머신 A에 j + a, B에 k만큼의 시간이 걸리게 되고, B에 할당한다면 머신 A에 j, B에 k + b만큼의 시간이 걸리게 될 것입니다. 

그렇다면, 우리는 다음과 같은 방법을 생각해볼 수 있을 것입니다.

i개 작업을 쓰면서 A에 j, B에 k의 시간을 배정하는 방법이 존재하는가?

만약 존재한다면, 그 상태에서의 최대 시간은 max(j, k)가 될 것이고, 결국 우리는, n번 작업에 대한 머신 A, B에 할당되어있을 수 있는 모든 경우의 수를 고려하여, 그 중 가장 작은 값이 곧 답이 된다는 것을 알 수 있습니다.

이를 실제 동적계획법으로 구현해보겠습니다.

F(i, j, k) = (i개 작업을 쓰면서 A에 j, B에 k의 시간을 배정할 수 있는가?)

와 같이 정의하고, 1이면 만들 수 있고, 0이면 만들 수 없다고 놓게 되면, 이는 각 i번 작업을 A에 배정했거나, B에 배정했을 두 가지 경우만 있기 때문에

F(i, j, k) = max(F(i - 1, j - a, k), F(i - 1, j, k - b))
F(0, 0, 0) = 1

과 같이 놓을 수 있게 됩니다. 이 때, A에 할당될 수 있는 최대 시간은, M을 (한 작업의 최대 작업시간)이라 놓게 되면, 최대 N*M의 시간까지 될 수 있음을 알 수 있습니다.

우리는 O(1)에 하나의 F를 구해줄 수 있기 때문에, 모든 F에 대해 이를 계산해준다면, 총 채워야하는 F의 수는 O(N * N*M * N*M) = O(N^3*M^2)이 된다는 것을 알 수 있습니다.

하지만 이는 아직도 작은 범위의 N과 M에 대해서만 답을 구할 수 있어, 아쉬움이 있습니다. 그렇다면 이를 조금 더 빠르게 만들 수 있는 방법이 있을까요?

위에 사용했던 식을 살펴봅시다.

F(i, j, k)

여기에서 각각 j와 k에 A와 B에 할당되어있는 시간을 인자로 쓰고 있고, 실제 F에는 가능한지 여부 1과 0만 사용되고 있습니다.
하지만 만약에 F가 우리에게 필요한 값을 가지고 있다면, 더 적은 인자만 쓰고도 문제를 해결할 수 있지 않을까요?

여기에서, 우리는 원래 문제에서 한가지 생각해 볼 것이 있습니다.
만약 A에 j만큼의 시간이 할당되어 있었고, B에 k만큼의 시간이 할당되어 있다고 합시다. 그렇다면, A에 j + 1만큼의 시간을 할당할 수 있다면, B에는 k보다 큰 시간이 할당될 수 있을까요?
절대 그런 경우는 없을 것입니다. 우리는 아무리 안좋은 상황이어도, 항상 A에 j, B에 k의 시간이 할당된 상태에서, B의 작업을 0개 이상 A로 옮기기만 해도 항상 B에 k만큼의 시간을 보장해줄 수 있습니다. 즉, A에 배정된 시간이 커질수록 항상 B에는 더 작거나 같은 시간을 배정해줄 수 있기 때문에, A가 증가하면 B는 감소하는 형태로 작업이 할당이 됩니다.

이를 실제로 반영하여 F를 생각해줍시다.

F(i, j) = (i번 작업까지 머신 A에 j만큼의 시간을 배정해줄 때, B에 배정할 최소 시간)

이와 같이 정의하게 되면, F는 다음과 같이 표현이 가능해집니다.

F(i, j) = min{F(i - 1, j) + b, F(i - 1, j - a)}
F(0, 0) = 0

즉, 앞서서 정의한 F를 지금까지 잘 구해놓은 상황이라면, 1~i-1번 작업까지 처리한 이후, 새로운 i번째 작업을 배정하는 경우는 이를 A 혹은 B에 배정하는 각각의 경우가 존재하게 됩니다.

이 상황에서 A가 i번 작업까지 끝났을 때에 j 시간을 사용했다면 이는 i번을 A에 배정하고, 그 이전에 j-a의 시간까지 작업을 했던 상황, 혹은 B에 배정하고 A는 이전에 j 시간 작업을 한 상황임을 의미합니다.
이 시점에, 새로운 작업을 A 혹은 B 이외에 다른 곳에 배정하는 경우는 존재할 수 없기 때문에, 우리는 모든 경우를 잘 처리했음을 알 수 있습니다.

그렇다면 위 식을 채우는데에는 얼마의 시간이 걸리게 될까요?

모든 작업을 보기 위해서는 총 N개의 작업에 대해 F를 채워야합니다. 이 때, A가 가질 수 있는 최대 작업 배정은, 모든 작업이 다 A에 배정되는 경우입니다.
이 때 A가 가지는 총 시간은 N*M이 되기 때문에, 전체 F의 상태 수는 N^2 * M이 됩니다.

F의 식은 모두 O(1)만에 처리가 가능하기 때문에, 총 시간 복잡도는 O(N^2*M)이 되고, 문제 상황에서 N과 M 모두 250이하이기 때문에, 1초 안에 해결할 수 있음을 알 수 있습니다.



# [곱셈](https://www.acmicpc.net/problem/1629)

## 관찰

어떤 수 A를 C로 나눈 몫을 p, C로 나눈 나머지를 r이라고 하면, 우리는 A를

- A = p * C + r

과 같이 나타낼 수 있습니다.
이처럼 A를 C로 나눈 몫과 나머지가 p, r이라고 할 때, A * A를 C로 나눈 몫과 나머지는 어떻게 될까요?
실제 계산해보면

- A * A = (p * C + r) * (p * C + r) = (Cp^2 + 2pr)C + r^2

이 된다. 이 때, (Cp^2 + 2pr) * C는 C로 나눈 나머지가 0이기 때문에, 실제로 남은 나머지는 r^2을 C로 나눈 나머지가 될 것입니다.

이처럼 C로 나눈 나머지가 0인 항은 다른 무슨 수와 곱해도 C로 나눈 나머지가 0이 되기 때문에, 우리는 몫을 고려하지 않고, 항상 A를 C로 나눈 나머지 r만 가지고 연산을 해도 문제가 되지 않습니다.

즉, A^3은 r^3을  C로 나눈 나머지와 같고, 이는 (((r * r을 C로 나눈 나머지) * r)을 C로 나눈 나머지) 와 같이 표현이 가능하여, 우리는 최종 수가 아무리 크다 하더라도, 중간에 곱해진 값들의 나머지들만 이용해서 계속 곱해나가더라도, 우리가 구하고자 하는 나머지 값과 항상 같아진다는 것을 알 수 있습니다.

이를 이용해 가장 쉽게 생각할 수 있는 방법은, A를 B번 곱해나가면서, 매 번 A, A^2, A^3, … 과 같이 A가 한 번 곱해질 때마다 C로 나눈 나머지 값을 저장해나가는 것입니다. 이렇게 할 경우 우리는 A^B이 얼마나 크든 상관없이 C로 나눈 나머지가 정수형 범위를 넘지 않는 다는 것을 이용해 답을 구해줄 수 있습니다. 
이 경우 우리는 곱해주는 횟수만이 중요해지므로, O(B)에 문제를 해결할 수 있습니다.

하지만 주어진 B 자체도 굉장히 크기 때문에, 우리가 아무리 O(B)로 문제를 풀어도 시간은 굉장히 부족합니다.

## 풀이

이 문제를 풀기 위해 앞서 관찰에서 발견했던 성질을 생각해봅시다. 우리는 A^B을 구하기 위해서, A^(B-1)을 C로 나눈 나머지와, A를 C로 나눈 나머지를 곱하고, 그 값을 다시 C로 나눈 나머지를 구함으로 답을 구했습니다. 이 때 우리는 어떤 두 수의 곱의 나머지는, 각 수의 나머지의 곱의 나머지를 구하는 것으로 해결이 가능했습니다.

그렇다면, A^B을 A와 A^(B - 1) 말고, 더 좋게 쪼개서 답을 구할 수 있지 않을까요?

B가 짝수일 때를 생각해봅시다. 이 경우, 만약 우리가 A^(B/2)의 값을 알 수 있다면, 우리는


- A^B = A^(B / 2) * A^(B / 2)

로 나타낼 수 있게 됩니다.
즉, 이를 최대한 절반씩 줄여나갈 수 있다면, A^(B / 2)를 구하기 위해서 A^(B / 4)를, A^(B / 8)을, 이를 반복하면 우린 약 lg B 개 정도의 값에 대해서만 알면 문제를 해결할 수 있다는 것을 알 수 있습니다.

홀수일 경우

- A^B = A^((B - 1) / 2) * A^((B - 1) / 2) * A

와 같이 만드는 것으로 짝수를 만들어 낼 수 있으므로, 우리는 모든 수에 대해 항상 절반씩 나누어나갈 수 있게됩니다.

함수 F를 다음과 같이 정의해봅시다.

- F(B) = (A^B를 C로 나눈 나머지)

그럴 경우, F를 어떻게 정의하면 될까요?

가장 작은 경우인 B가 1일 때에, A를 C로 나눈 나머지를 반환해주고,
나머지 경우엔 앞서 우리가 발견한 식을 이용해 구해보도록 합시다.

- F(B) = F(B / 2) * F(B / 2) % C			(B가 짝수)
	        = F(B / 2) * F(B / 2) % C * A % C	(B가 홀수)
	        = A % C					(B가 1)

이제 우리는 실제 F(B)를 구해주기만 하면 이 것이 답이 됨을 알 수 있습니다.
그렇다면 시간복잡도는 어떻게 될까요? 절반씩 나누었기 때문에 O(lg B)가 될까요?

사실 아직은 그대로 O(B)가 됩니다. 이를 알아보기 위해서는 각 F(B)가 어떻게 호출되는지 볼 필요가 있습니다.

예를 들어 F(8)이 호출되었다고 할 때, 각 F가 호출되는 그림을 그려봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_10_1.PNG)

결국, 매 높이마다 F는 2^(높이) 만큼 호출이 되기 때문에, 총 O(B)만큼의 함수가 호출되어, 아직도 시간복잡도는 변함이 없게 됩니다.

그렇다면, 앞서 배웠던 방법대로 메모이제이션을 쓰면 어떻게 될까요? 물론 메모이제이션을 쓰면 시간복잡도는 걱정하지 않아도 됩니다. 하지만 이 문제에서 B는 32bit 정수형 범위까지 가능하기 때문에, 이를 모두 기록할 수 있는 배열을 만드는 것은 어려운 일입니다.

즉, 우리는 그냥 시도해서는 메모이제이션을 쓰는 것 자체가 불가능하게 됩니다.
그렇다면, 어떻게 해야 시간복잡도를 줄일 수 있을까요?

1) 작은 범위만 메모이제이션

쉬운 방법으로는 메모이제이션을 ‘작은 범위에만 쓰는 것’으로 시간복잡도를 줄이는 것입니다. B의 범위까지의 모든 값들을 저장하는 배열을 만들 수는 없으므로, 약 100만(2^20)까지에 해당하는 값들만 메모이제이션을 한다고 합시다.

그렇게 될 경우, F(B)에서, B가 100만 이하일 경우 메모이제이션을 통해 호출을 크게 줄여줄 수 있게 됩니다.
이 때, 우리가 앞서 그린 그림을 보게 되면, B가 작아질 수록 호출하는 횟수가 2배씩 늘어간다는 것을 볼 수 있습니다. 허나 이제 100만 이하인 수는 딱 한 번씩만 보게 되기 때문에, 우리가 그린 그림에서 아래에서 20개까지의 높이는 없는 것처럼 볼 수 있게 됩니다. 

결국 그림에서 높이가 20만큼 줄어든 것과 같은 효과를 볼 수 있어, 우리가 보는 함수의 수는 B / 100만 개가 되어 시간을 크게 줄일 수 있게 됩니다.
(O(B / 100만) = O(B) 이지만, 계수가 매우 크게 줄어드므로 동작속도가 빨라집니다)

2) 실제 사용되는 값들만 메모이제이션

사실 우리가 F의 인자로 주게 되는 값들은 아무리 많아도 lgB + 2개를 넘지 않습니다. 즉, 우리는 몇백만, 몇억 정도 크기의 배열을 만들어도 실제 사용되는 값을 100개도 채 되지 않습니다. 그렇다면, 이처럼 배열을 만들어 메모이제이션 하는 것이 아니라, 실제 사용할 값들만 메모이제이션 하면 어떻게 될까요?

0번 배열에는 F(B)의 값이, 1번 배열에는 F(B / 2), 2번 배열에는 F(B / 4), …, 이를 반복해 약 lg B개의 배열에 값을 다 담고 나면, 우리는 어떤 값이 실제 기록이 되었는지 여부를 0번부터 lg B + 2까지의 값들만을 찾아보는 것으로 알 수 있게 됩니다. 이전처럼 한 번에 기록 여부를 판단할 수는 없지만, 100개도 채 되지 않는 수를 찾아보는 것은 크게 어렵지 않는 일이 됩니다.

결국 우리는 기록을 lg B 만에 찾는 메모이제이션을 쓴 것과 다름없게 되므로, 총 시간복잡도는 O(lg^2 B)가 되어 굉장히 빠르게 답을 찾을 수 있게 됩니다.
(실제 기록되는 값들은 굉장히 적기 때문에, 메모이제이션을 해싱을 쓰는 방법을 사용하면 약 O(lg B)에도 문제를 해결할 수 있게 됩니다.)

3) 식을 조금만 변형하기

실은 우리가 식은 조금만 변형해서 앞서 고려한 것들을 이용하지 않고도 O(lg B)를 만들어낼 수 있습니다. 아까 우리가 만든 식을 다시 가지고 옵시다.

- F(B) = F(B / 2) * F(B / 2) % C			(B가 짝수)
	        = F(B / 2) * F(B / 2) % C * A % C	(B가 홀수)
	        = A % C					(B가 1)

여기에서 시간복잡도에 많은 부분이 들었던 이유는 바로 F(B / 2)가 두 번 호출된다는 것이었습니다. 결국 이는 매 단계에서 함수의 호출을 2배씩 늘려 O(B)의 시간복잡도를 만들어 냈습니다.

그렇다면, 우리가 F(B)가 호출 되었을 때, F(B / 2)의 값을 T라는 변수에 기록을 하면 어떻게 될까요?(B가 1이 아닌 경우)

- F(B) = T * T % C			(B가 짝수)
	        = T * T % C * A % C		(B가 홀수)
	        = A % C				(B가 1)

이 때, T는 현재의 B에 대해 값이 변할리가 없기 때문에, 식에 나와있는 T, A, C 모두 상수가 됩니다. 즉, 우리는 F(B / 2)를 한 번만 호출하고도 남은 식들을 O(1)에 계산해줄 수 있게 됩니다.

그렇다면, T를 구하기 위해 호출되는 F(B)들을 그림으로 그리면 어떻게 될까요?

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_10_2.PNG)

매 순간 F(B), F(B / 2), F(B / 4), …, F(1)까지의 모든 값들이 한 번 씩만 호출되기 때문에 총 호출되는 함수의 수는 lg B + 2를 넘지 않습니다. 그리고 나머지 모든 연산은 상수이기 때문에, 우리는 총 O(lg B)에 문제를 해결할 수 있습니다.

# [달팽이는 올라가고 싶다 - COCI 2010/2011 Contest 2 1번](https://www.acmicpc.net/problem/2869)

## 관찰

달팽이는 낮 동안은 나무에 올라갔다가, 밤에는 나무에서 미끄러져 내려오게 된다는 조건이 있지만, 나무에 다 오르고 나면 더 이상 내려오지 않게 된다는 추가 조건으로 인해 어려움이 생깁니다.
만약 하루씩 기준으로 잡고 달팽이가 나무를 오른다 생각하면, 항상 낮에는 A만큼, 밤에는 B만큼 내려오므로 A - B씩 오른다 생각할 수 있었지만, 낮 동안 나무에 오르고 나면 B만큼 더이상 내려오지 않으므로, 매일 A - B씩 오른다는 방법으로 계산을 하기 어려워집니다.

그렇다면, 어떻게 이 문제를 해결할 수 있을까요?

가장 쉬운 방법으론 우리가 실제 달팽이가 나무를 오르는 과정을, 낮과 밤을 나누어 실제로 시뮬레이션하는 방법이 있습니다. 항상 낮에는 A만큼 오르고, 밤에는 B만큼 내려오므로, 첫째날 낮, 밤, 둘째날 낮, 밤 과 같이 하루하루 오르고 내려가는 일을 직접 구해준다면, 어느날 나무를 모두 오르게 되는지 알 수 있습니다.

하지만 이 방법으론 문제를 빠르게 해결하기 어려울 수 있습니다. 우리는 매일매일의 낮과 밤을 모두 계산해줘야하기 때문에, 우리는 ‘나무에 오르는 일수’ 만큼의 연산을 하게 됩니다. 이 때 만약 달팽이가 굉장히 오랜 시간 후에야 나무에 오르게 된다면? 우리의 방법으로도 오랜 시간 후에야 나무 꼭대기에 언제 도착하는지 알 수 있게 됩니다.

## 풀이

조금만 더 생각해보면, 문제를 조금 바꾸어 생각하는 것으로, 우리가 처음 생각한 아이디어를 적용시킬 수 있습니다.

처음에 우린 하루동안 달팽이가 A씩 오르고 B씩 내려가기 때문에, A - B씩 오른다 생각했지만, 낮 동안에 모두 오르면 밤에 떨어지지 않기 때문에 이 방법을 사용하기 어려웠습니다.

여기서 주목할 점은, ‘낮 동안에 모두 오르면 밤에 떨어지지 않는다’를 살펴보면, ‘낮 동안에 모두 오르지 않는다면, 밤에 떨어지게 된다’ 가 된다는 점입니다. 즉, 우리는 나무를 모두 오르게 되는 날이 아니라면, 항상 하루를 진행할 때에 A만큼 오르고, B만큼 내려와 총 A - B만큼 이동하게 됩니다.

또한 달팽이가 마지막 날에 나무를 오르게 된다면, 항상 낮에만 오르게 되므로, 마지막 날은 무조건 A만큼 나무를 오르게 된다는 것을 알 수 있습니다.


결국 우리는 이 문제를 ‘마지막 날에 A만큼, 나머지 날에는 A - B만큼 오르는 달팽이’ 문제로 생각할 수 있게 되므로, 마지막 날에 오르는 A를 제외한다면 우리는 V - A 높이의 나무를 매일 A - B씩 며칠만에 오를 수 있는지를 구하면 문제를 해결할 수 있습니다.

만약 이 A - B만큼 오르는 것을 하루하루 시뮬레이션을 한다면, 앞서 관찰에서 해결했던 방법에서 낮과 밤을 하루씩 건너뛰는 것만 달라지므로, 시간복잡도는 전혀 달라지지 않습니다. 이를 해결하기 위해 우리는 모든 날들을 시뮬레이션 하는 것이 아닌, 꼭 필요한 날들만 생각해줄 필요가 있습니다.

항상 달팽이는 하루만큼 지나면 나무에 조금이라도 더 올라가게 되므로, 만약 k일이 지나 달팽이가 처음으로 V - A만큼을 올라갈 수 있었다면, 우리는 다음 정보들을 얻을 수 있습니다.

- 0 ~ k - 1일이 지나는 것으로는 달팽이가 V - A만큼 올라갈 수 없다.
- k + 1일 이상이 지나는 것으로는 항상 V - A 이상 올라갈 수 있다.

이 정보를 이용하면 우리는 ‘V - A를 올라가는 가장 빠른 일수’ 를 구하는 문제로 볼 수 있게 되며, t일이 지나면 달팽이는 t * (A - B)만큼 올라간다는 사실을 이용해, 이분탐색으로 구한 날짜가 조건에 만족하는 날짜인지 확인할 수 있게 됩니다.

하루에 적어도 1만큼은 올라가기 때문에, 아무리 늦어도 V - A일 이후에는 올라간다는 사실을 이용하여 이분탐색의 범위를 정해줄 수 있고, 총 O(lg(V - A))에 문제를 해결할 수 있게 됩니다.

이 정도의 시간복잡도 만으로도 충분히 빠르게 해결할 수 있지만, 사실 위 방법보다 더 간단하게 문제를 해결할 수도 있습니다.

만약 V - A가 A - B의 배수가 된다면, 언제나 (V - A) / (A - B) 일이 지나면 V - A를 모두 오를 수 있게 되며, 만약 A - B의 배수가 아니라면 항상 하루만큼 더 지나게 된다면 V - A를 모두 오를 수 있게 됩니다. 이는 계산하는 것으로 어렵지 않게 알 수 있으며, 이를 이용해 이분탐색을 사용하지 않고도 며칠이 걸리는지 한 번에 계산할 수 있게 됩니다.

다만 V - A가 음수가 되는 경우도 있지만 실제 시간은 음수만큼 흐를 수 없기 때문에, 아무리 작아도 0일만큼 지나는 것으로 고려해준다면, 문제를 쉽게 해결할 수 있어 O(1)에 해결할 수 있게 됩니다.

# [최고의 피자 - JOI 2012 예선 3번](https://www.acmicpc.net/problem/5545)

## 관찰

만약에 도우가 없다면 어떻게 될까요?

우리가 토핑 중에서 여러개를 골라서 1원당 가장 큰 열량을 가진 피자를 주문하는 상황으로 문제가 바뀌게 됩니다. 그렇다면 어떤 토핑들을 고르는게 가장 최대가 될까요?

정답을 바로 가장 큰 토핑을 하나만 사용하는 것입니다. 모든 토핑들은 다 같은 값을 가지고 있기 때문에, 우리가 구하고자 하는 1원당 열량은 (토핑 열량의 합) / (토핑의 수 * 토핑 가격) 이 됩니다. 이 때, 토핑 가격의 경우 항상 동일하게 되므로, 우리는 (토핑 열량의 합) / (토핑의 수) 를 최대화하는 것과 같이 볼 수 있는데, 이 상황에서는 가장 큰 하나의 토핑을 제외하고는, 다른 토핑들을 사용하지 않는 것이 가장 최선임을 어렵지 않게 알 수 있습니다.

그렇다면 지금 문제에서도 가장 큰 토핑 하나를 사용하는 것이 답이 될 수 있을까요?

앞선 예시를 살펴보는 것으로 확인해볼 수 있습니다.

만약 300인 2번 토핑만 사용한다면, 1원당 열량은 (200 + 300) / (12 + 2) = 20.83이 되어, 37.5보다 더 작아진다는 것을 알 수 있습니다. 이 이유는 우리가 기본으로 사용하는 도우의 열량과 그 때의 가격이 존재하여 토핑이 차지하는 가격 지분과 열량 지분이 달라지기 때문에, 토핑을 추가함으로 더 많은 이득을 볼 수도 있기 때문입니다.

## 풀이

그렇다면, 우리는 하나의 도우를 사용하는 시점에서 어떤 토핑을 사용해야 최고의 피자를 만들 수 있을까요?

앞선 방법과 같이 1개의 토핑만 사용하는 것은 꼭 답이된다는 보장이 없음을 알 수 있습니다.

즉, 우리는 0~N 종류의 토핑을 모두 사용해보는 것을 통해, 이중에 가장 큰 값이 되는 피자를 최고의 피자라고 생각할 수 있습니다.

허나, 이를 단순하게 구현한다면, 모든 토핑에 대해 사용한다, 하지 않는다 2개의 선택지가 있으므로, 총 2^N 가지의 경우가 존재함을 알 수 있습니다. 이를 어떻게 개선할 수 있을까요?

우리가 만약 K개의 토핑을 사용한다고 생각합니다. 이 때, 우리는 어떤 토핑을 사용하는 것이 최선이 될까요?

모든 토핑들은 모두 같은 가격을 가지고 있기 때문이, 총 추가되는 가격은 K * B임을 알 수 있습니다. 즉, 우리가 어떻게 선택해도 항상 같은 가격이 추가되므로, 우리는 최대의 열량을 가지는 K개의 토핑을 추가하는 것이 최선임을 알 수 있습니다.

즉, 0~N개의 토핑을 올리는 각각의 상황마다, 가장 큰 열량을 가진 토핑부터 피자에 추가하는 것이 항상 최선의 결과를 낼 수 있게 됩니다.

따라서, 모든 토핑들을 열량에 대한 내림차순으로 정렬한 이후, 0개의 토핑을 올리는 경우에서부터 가장 큰 토핑을 올린 1개의 토핑을 올리는 경우, 2~N번째 토핑까지 순서대로 피자에 올려보면서, 이중 가장 큰 1원당 열량을 가지는 값이 최고의 피자가 되는 것으로 계산하여 문제를 해결할 수 있습니다.

토핑을 정렬하는데 O(NlgN), 0~N번째 토핑을 순서대로 보는데 O(N)이 걸리므로, 우리는 총 O(NlgN)에 문제를 해결할 수 있습니다.

# 코드

## Musical Notes 1

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
int arr[50010];

int main(){
	int i, a, sum = 0;
	scanf("%d %d", &n, &m);
	for(i = 0; i < n; i++){
		scanf("%d", &a);
		sum += a;
		arr[i] = sum;
	}
	for(i = 0; i < m; i++){
		scanf("%d", &a);
		printf("%d\n", upper_bound(arr, arr + n, a) - arr + 1);
	}
	return 0;
}
```

## Musical Notes 2

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Data{ int x, idx, v; };

int n, m;
int arr[50010];
Data marr[50010];

bool compare1(Data d1, Data d2){
	return d1.x < d2.x;
}
bool compare2(Data d1, Data d2){
	return d1.idx < d2.idx;
}
int main(){
	int i, a, sum = 0;
	scanf("%d %d", &n, &m);
	for(i = 0; i < n; i++){
		scanf("%d", &a);
		sum += a;
		arr[i] = sum;
	}
	for(i = 0; i < m; i++){
		scanf("%d", &a);
		marr[i] = (Data){a, i, -1};
	}
	sort(marr, marr + m, compare1);
	a = 0;
	for(i = 0; i < m; i++){
		while(a < n && arr[a] <= marr[i].x) a++;
		marr[i].v = a + 1;
	}
	sort(marr, marr + m, compare2);
	for(i = 0; i < m; i++) printf("%d\n", marr[i].v);
	return 0;
}
```

## 곱셈

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll c;

ll f(ll a, ll b){
	ll now;
	if(b == 1) return a % c;
	now = f(a, b / 2);
	return now * now % c * ((b % 2 == 1) ? a : 1) % c;
}
int main(){
	ll a, b;
	scanf("%lld %lld %lld", &a, &b, &c);
	printf("%lld", f(a, b));
	return 0;
}
```

## 달팽이는 올라가고 싶다

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll a, b, v;

int main(){
	ll now = 1;
	scanf("%lld %lld %lld", &a, &b, &v);
	v -= a;
	printf("%lld", now + max(0ll, (v / (a - b) + ((v % (a - b) && v > 0) ? 1 : 0))));
	return 0;
}
```

## 최고의 피자

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a, b, c, max1, sum;
int arr[110];

int main(){
	int i;
	scanf("%d %d %d %d", &n, &a, &b, &c);
	for(i = 0; i < n; i++) scanf("%d", &arr[i]);
	sort(arr, arr + n);
	max1 = c / a;
	for(i = n - 1; i >= 0; i--){
		sum += arr[i];
		max1 = max(max1, (c + sum) / (a + (n - i) * b));
	}
	printf("%d", max1);
	return 0;
}
```
