---
layout: post
title: "Quantum Graph"
date: 2023-04-23
author: red1108
tags: [computer-architecture, stack-memory, heap-memory, memory]
---

## 서론

> 이 글은 우리가 짠 C/C++ 코드에서 자주 신경쓰지는 않았던 스택과 힙 메모리에 대해 다룬다. 재귀함수가 왜 스택 메모리를 잡아먹고, 얼마나 잡아먹는지, 그리고 왜 큰 배열은 함수 안에 만들면 터지는데 전역변수로 만들면 괜찮은지, 구조체는 메모리를 얼마나 잡아먹는지를 다룬다.

## 들어가며...

우리가 PS(Problem Solving) 또는 CP(Competitive Programming)를 처음 접하고, 재미를 느끼면서 실력이 발전해나가는 과정에서 주된 관심사가 달라지게 된다고 생각한다.
좀 더 구체적으로 설명하자면, 처음 PS를 할 때는 어떻게 코드를 짜야하는가, 어떻게 해야 컴파일 에러가 나지 않는지가 주된 관심사이다. *(요즘엔 다들 PS를 어떤 언어로 접하는지는 모르겠지만, 아마 C++일 것이므로 C/C++언어를 기준으로 설명하겠다 )*. for문에는 세미콜론이 두개가 들어가고, if문 뒤에는 세미콜론이 붙지 않지만, do-while문 뒤에는 세미콜론이 붙고... 이런식으로 사소한 문법도 신경쓸 게 너무 많다고 느껴진다.
여기서 실력이 좀 더 발전한다면 문법 자체에는 익숙해졌지만, 어떤 코드를 적재적소에 위치시켜야 하는지를 고민하게 될 것이다. 아직 문제를 해결하기 위한 자신의 아이디어를 구조화하고 어떻게 해야 코드로 잘 옮길 지 익숙하지 않기 때문이다.
PS는 성격이 주어진 알고리즘 문제를 해결하는 것에 초점이 맞추어져 있기 때문에, 빨리 코딩에 익숙해지기 위하여 **코딩할 때 여러 사항들을 외우고 지나가는 경향이 있다.** 여러가지가 있겠지만, 아래 것들이 흔히 가지는 의문들이다.

1. 왜 지역변수에는 배열을 크게 잡으면 안 되는 걸까? (boj를 포함한 여러 사이트에서는 문제 없는 경우도 있다)
2. 재귀함수는 어떻게 동작하는 걸까?
3. 구조체와 배열은 컴퓨터에서 어떻게 저장될까?

이런 주의사항들이 왜 생겼는지 모른 채로 외우고 넘어가는게 나쁘다는건 전혀 아니다. 오히려 코딩하는데 사소한 것들까지 전부 신경쓰며 코딩하는건 효율적이지 않다. 그리고 우리가 기계어나 어셈블리어로 코딩하지 않고 C/C++이나 파이썬처럼 고급 언어를 사용하는 이유 중에 하나이기도 하다. 그래도 궁금한 건 궁금한 거니 이 글에 조금 정리해 보고자 한다.

## 지역변수와 전역변수의 메모리 제한

왜 지역변수에는 배열을 몇십만 개만 잡아도 런타임 에러(segmentation fault)가 나는데 전역변수는 괜찮은 걸까?

이유는 간단하다. 지역변수는 스택 메모리에 저장되고 전역변수는 힙 메모리에 저장되는데, 기본적으로 스택 메모리의 용량 제한이 힙 메모리보다 훨씬 작기 때문이다. (컴파일 설정에 따라 얼마든지 바뀔 수 있으며, boj의 경우엔 스택메모리의 메모리 제한을 따로 지정하지 않아서 전역변수처럼 배열을 크게 잡을 수 있다)

그렇다면 스택 메모리와 힙 메모리는 무엇이 다른걸까? 

## 재귀함수는 어떻게 작동하는걸까?

우리는 프로세스가 하는 일을 전부 코드로 구현해줄 필요가 없다. 규칙에 따라 어떤 동작을 반복하도록 지시할 수 있기 때문이다. 대표적으로 for과 while, do-while문이 있다. 하지만 이 세 반복문은 컴퓨터가 해석하기에도 단순하게 느껴지고 실제로도 단순하다. 하지만 재귀함수는 어떨까? 재귀함수는 여러번 함수를 타고 들어갈 수 있고, 각 함수마다 지역변수들이 독립적으로 존재하기 때문에 컴퓨터가 어떻게 재귀함수를 구현하는지 의문이 들 수 있다. 과연 재귀함수는 어떻게 구현되는 걸까?

재귀함수를 배우다 보면 재귀함수와 스택이 연관성이 깊다는걸 배울 것이다. 재귀함수에서 가장 먼저 호출된게 가장 나중에 return되듯이, stack에 가장 먼저 들어온 원소는 가장 마지막에 나간다. 이러한 유사점에서 예측해 볼 수 있듯이, 재귀함수는 스택으로 구현된다.

컴퓨터의 스택 메모리에는**스택 포인터**가 존재한다. 편의상 sp라고 부르자. 

## 구조체는 메모리를 얼마나 잡아먹을까?

구조체는 여러 자료형이 한데 어우러져 새로운 자료형을 만든다. 그런데 이런 자료형은 메모리 계산이 어떻게 될까? 아래와 같은 코드를 보자.

```cpp
struct Foo {
    int a;
    long long int b;
    char c;
};
```

위 코드에서 구조체 `Foo`는 `int`, `long long int`, `char`타입의 변수를 담고 있다. `int`는 4byte, `long long int`는  8byte, `char`은 1byte의 용량을 차지한단 것은 잘 알려진 사실이다. 그렇다면 1개의 Foo변수는 4+8+1 = 13byte를 차지할까? 이랬으면 좋겠지만, 실제로는 이렇게 단순하지 않다.

struct가 차지하는 용량은 단순히 포함된 자료형의 크기를 다 합친 것보다도 크다. 이 때문에 구조체 배열을 만들어 사용하다 보면 예상과 달리 메모리 제한 초과가 발생할 수도 있다.

그렇다면 **구조체의 용량**은 어떻게 계산되는 걸까?