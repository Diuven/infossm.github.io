---
layout: post
title:  "알고리즘 문제 접근 과정 3"
date:   2021-09-19 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 3

이번 포스트에서도 '알고리즘 문제 접근 방법 1, 2'에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [보석 - Taejon Asia Regional 2001 B번](https://www.acmicpc.net/problem/2492)

## 관찰

금강석의 수를 최대화하기 위해서는, 팔 수 있는 모든 땅을 다 한 번씩 파 몇 개를 얻을 수 있는지 기록한 다음에, 그 중 가장 많이 캘 수 있었던 금강석의 수를 알아내면 됩니다.

가장 쉬운 방법으로는 실제로 파볼 수 있는 모든 영역을 지정하여, 그 안에 속한 금강석의 수를 세는 방법입니다. 지도는 총 $N * M$개의 격자가 있기 때문에, 우리가 확인해야하는 영역은 최대 $(N - K + 1) * (M - K + 1)$ 만큼의 땅을 파는 경우의 수들이 있고, 이 때의 영역마다 $T$개의 금강석에 대해 각각 이 영역에 포함되는지를 판단해주면 됩니다.

하지만 이 경우는, $K$가 1일 경우에 총 $N * M$번 땅을 파야하고, 우리는 $T$개의 금강석을 모두 보기 때문에 최악에 $O(NMT)$가 걸리는 방법이 됩니다. 지도의 크기가 충분히 작다면 이를 이용해서 해결할 수 있지만, 우리는 좀 더 나은 방법을 통해 더 빠르게 해결해야합니다.

우리는 앞서 다뤘던 내용을 통해 모든 경우를 해보면서, 더 빠르게 해결할 수 있습니다. 한 번 주어진 금강석들의 위치는 우리가 어디에 있는 땅을 파도 변하지 않습니다. 이 성질을 이용해서, 특정 영역에 속해있는 금강석의 수를 쉽게 구할 수 있을까요?

이전에 배웠던 ‘이차원 구간합’을 계산할 수 있는 표를 미리 작성한다면, 우리는 특정 구간에 있는 금강석의 수를 쉽게 구할 수 있습니다.

- $A[i, j] = (i, j)에 있는 금강석의 수$

라고 정의할 경우, 우리는 $T$개의 금강석이 각각 $x_{i}, y_{i}$ 좌표를 가질 때, $A[x_{i}, y_{i}]$를 1 증가시키는 것으로 $A$ 배열을 모두 채워줄 수 있습니다.

이제 구간합을 구하기 위해 다음과 같이 $S[i, j]$를 정의해봅시다.

- $S[i, j] = (0, 0)부터 (i, j) 사이에 있는 금강석의 수)$

이 때, 우리가 $i$를 0부터 $1$씩 증가해가고, 같은 $i$에 대해 $j$를 0에서부터 증가시킨다면

- $S[i, j] = S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + A[i, j]$

를 통해 $S$ 배열을 모두 채워줄 수 있습니다.

이렇게 모든 $S$ 배열을 채워주게 된다면, 우리는 $(a, b)부터 (c, d) 사이에 있는 금강석의 수$는

- $S[c, d] - S[c, b - 1] - S[a - 1, d] + S[a - 1, b - 1]$

이 곧 금강석의 수가 됨을 이용하여 $O(1)$에 구해줄 수가 있습니다.
이를 통해 특정 정사각형이 결정되면, 금강석의 수는 바로 구해줄 수가 있어, 시간복잡도는 정사각형을 결정하고, $S$배열을 채우는데 드는 시간인 $O(NM)$으로 줄어들게 됩니다.

하지만 아직까지도 지도는 굉장히 클 수가 있습니다. 우리는 이 시간복잡도도 더 빠르게 만드는 방법을 찾아야합니다.

## 풀이

우리에게 문제가 되는 부분은, 지도상에 있는 금강석의 수는 적을 수 있는 반면에, 지도 자체는 굉장히 클 수 있다는 점입니다. 그렇기에 우리가 땅을 파는 과정에서, 꼭 살펴보지 않아도 되는 쓸모없는 땅들(이미 이보다 더 많은 금강석을 포함하는 땅을 찾은 경우)을 너무 많이 확인하게 됩니다.
하지만 우리는 어떤 땅들이 쓸모없는 땅인지를 알아내기가 쉽지 않습니다. 그렇기에, 우리는 우리가 알 수 있는 특별한 경우에 포함되는 일부 땅들을 살펴보는 것으로, 더 빠르게 해결하는 방법을 생각해봐야 합니다.

다음과 같은 땅을 팠을 때를 생각해 봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_3_1.PNG)

우리는 위 정사각형이 지도에서 가장 최대가 되는 사각형이라는 사실을 알고 있습니다만, 현재 우리가 빨간색 땅을 파서 5개의 금강석을 캘 수 있다는 사실을 아는 상태에서, 나머지 격자에는 금강석이 어디에 존재하는지 모른다고 가정해봅시다.

이 때, 우리는 정사각형을 옮겨서 ‘확실히 현재 영역보다 더 좋은 결과를 내는 정사각형’을 만들 수 있을까요?
정사각형을 살펴보면, 윗변과 왼쪽, 오른쪽 변은 모두 금강석을 포함하고 있기 때문에 이를 이동시키면 항상 1개의 금강석을 손해보게 됩니다. 이 때, 옮긴 위치에 금강석이 없다면 우리는 더 안좋은 방향으로 이동시킨 꼴이 됩니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_3_2.PNG)

**파란색과 초록색 정사각형 모두 하나의 금강석을 잃어 포함한 금강석이 4개로 줄어듭니다.**

하지만 아랫변은 하나의 금강석도 포함시키고 있지 않습니다. 그러면 이 붉은 정사각형을 위로 1칸 옮겨보도록 하겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_3_3.PNG)

**초록색 범위의 금강석 5개는 모두 포함하면서, 아무것도 없는 붉은색 빗금영역은 제외하고, 금강석이 더 있을 수 있는 파란색 빗금영역이 추가됩니다.**

옮긴 정사각형은 아직도 5개의 금강석을 포함하고 있지만, 추가로 위로 1칸만큼의 직사각형을 더 포함하게 되었습니다. 만약 여기에 1개 이상의 금강석이 존재한다면, 이는 현재 우리가 구한 답보다 더 좋은 답이 될 것입니다.

이를 통해 알 수 있는 점은, 우리가 가진 정사각형의 특정 변이 아무 금강석도 포함하고 있지 않다면, 그 반대 방향으로 이동시켰을 때 더 좋은 답을 얻을 수 있다는 것입니다. 우리는 이를 이용해, 우리가 확인할 모든 정사각형을 ‘왼쪽 변 윗 변이 모두 금강석에 닿아있는 정사각형’ 만 확인하게 된다면 우리가 구하고자 하는 답을 똑같이 구할 수 있습니다. (왼쪽, 혹은 윗변이 금강석과 닿아있지 않을 경우, 각각 반댓 방향으로 칸을 옮기면 더 좋은 답이 됩니다.)
그렇다면, 어떻게 금강석과 닿아있는 정사각형을 모두 구할 수 있을까요?

금강석은 각각 x, y좌표를 하나씩 가지고 있고, 금강석은 총 T개가 있습니다. 즉, 이 T개의 좌표에 속하지 않는 점들은 각각 아래, 혹은 오른쪽으로 이동하여 하나 이상의 금강석에 닿게 만들 수 있습니다.
정사각형의 왼쪽 위 좌표를 T개의 금강석이 가질 수 있는 좌표들로 만들게 된다면, x좌표가 T개, y좌표가 T개 있으므로 총 T^2개의 정사각형들만 확인하면 된다는 것을 알 수 있습니다.

결국, T^2개의 정사각형에 대해 T개의 금강석 중 몇 개가 포함되는지 확인하는 것으로 문제를 해결할 수 있고, 총 시간복잡도는 O(T^3)으로 충분히 빠른 시간에 해결할 수 있게 됩니다.

### 추가 풀이

우리에게 주어진 격자의 크기는 굉장히 크지만, 실제로는 T개의 금강석이 존재하는 x, y 좌표를 제외하고는 사용할 필요가 없다는 점을 알 수 있었습니다.
이 때, T * T 격자를 만들어주고, 각각의 금강석이 존재하는 좌표에다가 금강석의 갯수가 1개 증가했다는 것을 반영하여 누적합을 계산한다면 어떻게 될까요?

우리가 실제로 확인해야하는 정사각형은 총 T^2개만 존재하므로, 각각의 정사각형들에 대해서 모든 금강석을 확인하는 것이 아닌, 특정 영역의 누적합을 구하는 방법을 사용하여 O(1)에 해당 영역의 금강석을 알아낼 수 있게 됩니다. 
허나 관찰에서 다루었던 것과 격자가 달라졌기 때문에, 누적합을 적용할 때에 직사각형의 x축 좌표들과 y축 좌표들이 바로 알아낼 수는 없다는 문제가 생깁니다. 이를 해결하기 위해서 two pointer 방법을 사용하여, 직사각형 x축 변으로 사용할 수 있는 구간들과 직사각형의 y축 변으로 사용할 수 있는 구간들을 구해놓는 방식으로 전처리를 해주거나 누적합을 구하는 과정에서 수행해줄 필요가 있습니다.

해당 부분에 대해 한 번 생각해보시고 O(T^2)으로 해결하는 코드도 구현해보는 것을 추천합니다.

# [쇼핑몰 - KOI 2019 1차대회 고등부 1번](https://www.acmicpc.net/problem/17612)

## 관찰

실제로 위와 같은 쇼핑몰에서 계산이 진행된다면 어떤 식으로 이루어지게 될까요?

모든 사람들이 처음에는 줄을 서있다가, 가장 앞에 있는 사람부터 계산대에 자리가 남아있는지 확인하고, 만약 남아있는 자리가 있다면 이 중 가장 번호가 작은 계산대에 들어가게 될 것입니다.

이렇게 앞에 서있는 사람부터 계산대에 들어가다가, 만약에 계산대에 아무런 빈 자리가 없다면, 우리는 계산대에서 계산을 마치고 빈 자리가 날 때까지, 줄을 서있는 어떤 사람도 물건을 계산할 수 없게 됩니다.

즉, 우리는 다음과 같은 전략을 세워볼 수 있습니다.

- 계산대에 빈 계산대가 존재한다면 가장 앞에서부터 사람들을 채워넣는다
- 계산대에 빈 계산대가 존재하지 않다면 각 계산대에서 물건을 하나씩 계산하여 빈 계산대가 생길 때까지 계산을 진행하고, 동시에 빈 계산대가 생길 때에는 번호가 큰 계산대에서부터 손님이 나가도록 한다
- 빈 계산대가 생긴다면 줄의 가장 앞에 서 있는 사람을 가장 작은 계산대부터 다시 채워넣는다
- 줄에 아무런 사람도 서있지 않다면 모든 계산대에서 계산을 진행한다.

그렇다면, 이러한 방법으로 문제를 해결할 수 있을까요?

모든 $K$개의 계산대에 대해 여러 물건이 아닌 1개의 물건씩 계속해서 계산해주어야 하며, $N$명의 손님을 받을 수 있기 때문에 꽤 오랜 시간이 걸릴 수 있다는 생각을 해볼 수 있습니다.

우리가 문제에서 나올 수 있는 한 계산대가 최대로 계산해야하는 시간이 $NW$까지 나올 수 있다는 점과, 우리가 $K$개의 계산대에 대해 시뮬레이션 해야하므로, 꽤나 오랜 시간이 걸릴 수도 있을 것 같습니다.

그렇다면, 어떤 방법으로 문제를 생각해볼 수 있을까요?

우리는 주어진 문제를, 빈 계산대를 만들어 줄의 앞 사람을 추가하는 방식이 아니라, 처음부터 어떤 사람이 어느 계산대에서 계산할 지 알려주는 방법은 없을까요?

## 풀이

모든 줄을 서있는 사람들이 자신이 어떤 계산대에 서게 될지 배정해 줄 방법을 생각해봅시다.

우리는 어떤 사람이 이용할 계산대는 비어있는 계산대이기 때문에, 다르게 생각한다면 남아있는 물건의 양이 가장 적은 계산대를 사용하는 것으로 생각할 수 있습니다. 즉, 이를 이용하여 모든 사람들을 순서대로 계산대에 다음 조건을 만족하면서 배정해봅시다.

- 남아있는 물건이 가장 적은 계산대 중
- 가장 번호가 앞선 계산대

즉, 처음에 $K$명의 사람들을 모두 순서대로 계산대에 배정해주고 나면, $K+1$번 사람은 모든 계산대 중에 남은 물건이 가장 적고, 번호가 작은 계산대에 배정을 해주는 식으로 어떤 계산대에서 계산을 할지 먼저 알려주는 방법을 사용할 수 있습니다.

이 과정에서, $N$명의 사람들에 대해 $K$개의 계산대를 모두 확인하여 한 명씩 배정해주므로 총 $O(NK)$의 시간이 걸리게 됩니다.

그렇다면 계산대에서 빠져나갈 때에는 어떻게 될까요?

우리는 물건을 계산한 시간이 가장 이르고, 같은 경우 번호가 가장 큰 계산대부터 나간다는 사실을 알 수 있습니다. 즉, 다음을 고려해봅시다.

- $K$개의 계산대에 가장 앞에 서있는 사람 중
- 계산이 끝나는 시간이 가장 이른 사람들 중
- 번호가 가장 큰 계산대에 서 있는 사람

어차피 계산대의 뒤에 서 있는 사람은 앞에 서 있는 사람보다 더 늦게 계산이 끝나게 되므로, 우리는 위와 같은 방법으로 $K$개의 계산대를 확인 하는 것으로, 다음에 나갈 사람을 알 수 있게 됩니다.

이 때에도 총 $K$개의 계산대를 $N$번 보게 되므로, $O(NK)$의 시간이 들어 총 $O(NK)$에 문제를 해결할 수 있습니다.

허나 이러한 경우도 아직 문제를 빠르게 해결하기엔 느려보입니다. 그렇다면 어떤 방법을 이용해야 할까요?

우리는 이전에 다음 작업을 빠르게 하는 자료구조를 생각할 필요가 있습니다.

- N개의 원소 중 가장 작은 값을 $O(lgN)$에 구하는 자료구조

만약 위 작업을 사용할 수 있다면, 우리는 사람들을 계산대에 배정할 때에, $K$개의 계산대 중 가장 남아있는 물건이 적은 계산대를 $O(lgK)$에 구할 수 있고, 계산대에서 나오는 사람을 구할 때에도 가장 앞에 서 있는 최대 $K$명의 사람 중 가장 이르게 나오는 사람을 $O(lgK)$에 구해줄 수 있게 되어 총 $O(NlgK)$에 문제를 해결할 수 있게 됩니다.

우리는 위 연산을 할 수 있는 자료구조로 heap 구조를 사용할 수 있습니다. 이를 이용하면 충분히 빠른 시간을 갖는 시간복잡도를 구할 수 있어, 시간내에 문제를 해결할 수 있게 됩니다.

## 번외 풀이

사실 우리가 관찰에서 생각한 실제로 시뮬레이션을 통해 물건을 하나씩 계산하며 배정해주는 풀이는 한 사람이 가진 물건의 수가 작을 때에 꽤나 빠르게 동작한다는 사실을 알 수 있습니다.

관찰에서 엄밀히 언급하지는 않았지만, 우리가 우려했던 부분은 $N$명의 사람들이 있고 $K$개의 계산대가 있을 때에, 물건을 하나씩 시뮬레이션으로 계산하게 되므로 최악에 $K$개의 계산대에 대해 $NW$만큼의 시간을 시뮬레이션 해줘야하므로 $O(NKW)$ 만큼의 시간이 걸릴 수도 있을 것이라는 우려에서 시작합니다.

허나 실제로는 위 시간보다 훨씬 빠르게 동작합니다.

우리는 최대 $NW$만큼의 시간을 시뮬레이션 해야할 수도 있지만, 이 경우는 계산대가 하나 존재할 때에 발생합니다. 즉, $K$가 최대가 되는 상황에서도 $NW$의 시간이 유지가 되지는 않습니다.

잘 생각해보면 우리는 $K$개의 계산대가 존재할 때에, 최대로 오래 걸리는 계산대는 $NW / K + W$를 넘지 않는 다는 것을 알 수 있습니다. 모든 계산대들의 물건의 수 차이가 $W$보다 크다면, 가장 큰 계산대의 마지막 고객이 다른 계산대에서 줄을 서게 될 것이기 때문에, 모든 계산대는 $W$를 넘지 않는 선에서 고르게 물건이 분포되어야 합니다.

즉, 실제로 시뮬레이션 해줄 물건의 최대 수는 $NW / K + W$이므로, 우리가 고려할 최대 시간을 $O((NW / K + W) * K)$ = $O((N+K)W)$ 가 되어, 물건의 수가 충분히 작을 때에 꽤나 빠르게 문제를 해결 할 수 있습니다. 

# 코드

## 나무 막대

```cpp
#include <bits/stdc++.h>
using namespace std;

struct data{ int l, w; } arr[5010];

int T, n, m;
int warr[5010];

bool compare(data d1, data d2){ if(d1.l == d2.l) return d1.w < d2.w; return d1.l < d2.l; }

int main(){
	int p, i, j, now, idx;
	scanf("%d", &T);
	for(p = 0; p < T; p++){
		scanf("%d", &n);
		for(i = 0; i < n; i++) scanf("%d %d", &arr[i].l, &arr[i].w);
		sort(arr, arr + n, compare);
		m = 1; warr[0] = arr[0].w;
		for(i = 1; i < n; i++){
			now = -1; idx = m;
			for(j = 0; j < m; j++) if(warr[j] <= arr[i].w && warr[j] > now) now = warr[j], idx = j;
			if(idx == m) warr[m++] = arr[i].w;
			else warr[idx] = arr[i].w;
		}
		printf("%d\n", m);
	}
	return 0;
}
```

## 쇼핑몰

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

struct data{ ll a, s, d; };
struct cmp{
	bool operator()(data d1, data d2){
		if(d1.a == d2.a) return d1.s > d2.s;
		return d1.a > d2.a;
	}
};

int n, m;
priority_queue <data, vector<data>, cmp> pq1, pq2;

int main(){
	int i;
	ll a, s, res = 0;
	data now;
	scanf("%d %d", &n, &m);
	for(i = 0; i < m; i++) pq1.push((data){0, i, 0});
	for(i = 0; i < n; i++){
		scanf("%d %d", &a, &s);
		now = pq1.top(); pq1.pop();
		pq1.push((data){now.a + s, now.s, a});
		pq2.push((data){now.a + s, -now.s, a});
	}
	i = 1;
	while(!pq2.empty()){
		now = pq2.top(); pq2.pop();
		res += i * now.d;
		i++;
	}
	printf("%lld", res);
	return 0;
}
```

## 쇼핑몰 - 번외풀이

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

struct data{ int v, idx; };

ll sum;
int n, k, cnt, ncnt = 1;
data arr[100010], counter[100010];

int main(){
	int i, v, idx, flag = 1;
	scanf("%d %d", &n, &k);
	for(i = 0; i < n; i++){
		scanf("%d %d", &idx, &v);
		arr[i] = (data){v, idx};
	}
	for(i = 0; cnt < n && i < k; i++){
		counter[i] = arr[cnt++];
	}
	while(flag){
		flag = 0;
		for(i = k - 1; i >= 0; i--){
			if(counter[i].v) counter[i].v--, flag = 1;
			if(!counter[i].v && counter[i].idx){
				sum += 1ll * ncnt++ * counter[i].idx;
				counter[i].idx = 0; flag = 1;
			}
		}
		for(i = 0; cnt < n && i < k; i++){
			if(!counter[i].v) counter[i] = arr[cnt++], flag = 1;		
		}
	}
	printf("%lld", sum);
}
```


