---
layout: post
title:  "알고리즘 문제 접근 과정 6"
date:   2021-12-19 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 6

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [Exhibition - JOI 2019 2번](https://www.acmicpc.net/problem/16981)

주어진 문제가 영문이기 때문에 번역을 하여 문제를 첨부하겠습니다.

## 문제

알고박물관에서는 새해를 맞이해 여러 작품들을 특별 전시하려 합니다. 이번 특별 전시는 매우 귀한 작품들을 가지고 전시할 것이기 때문에, 전시하는 모든 작품들을 액자에 끼워서 전시하려 합니다. 알고박물관에서는 특별 전시를 위한 작품 N개의 후보를 뽑았습니다. 1번부터 N번까지의 각 작품들은 크기 Si와 작품의 가치 Vi를 가지고 있습니다.
알고박물관은 특별전시를 위한 M개의 액자를 가지고 있습니다. 각 액자는 크기 Cj를 가지고 있고, 이 액자에는 크기가 Cj이하인 작품들만 넣을 수 있습니다. 또한 한 액자에는 최대 하나의 작품만 넣을 수 있습니다.
특별전시는 관람객의 편의를 위해 다음과 같은 순서로 전시하려 합니다.

-	액자들은 크기가 항상 작거나 같아지는 순서로 놓기(액자 번호순일 필요는 없음)
-	액자 내 작품의 가치들이 항상 작거나 같아지는 순서로 놓기

알고박물관은 위 두 조건을 만족하면서 최대한 많은 작품을 전시하고 싶습니다. 알고박물관이 전시할 수 있는 작품의 수는 몇 작입니까?

## 예시

각 작품이 (크기, 가치)를 가지고 있다고 할 때, 3개의 작품이 각각 (10, 20), (5, 1), (3, 5)를 가지고 있고, 4개의 액자가 각각 4, 6, 10, 4의 크기를 가지고 있으면, 3번째 액자에 1번 그림을, 2번 액자에 2번 그림을 넣으면 총 2개의 작품을 전시할 수 있습니다.

## 입력

첫 번째 줄에 공백을 사이에 두고 작품의 수 N(1 <= N <= 10^5), 액자의 수 M(1 <= M <= 10^5)가 주어집니다.
두 번째 줄부터 N개의 줄에 거쳐 각각의 작품의 크기 $S_{i}(1 <= S_{i} <= 10^9)$, 작품의 가치 $V_{i}(1 <= V_{i} <= 10^9)$가 주어집니다.
이후 M개의 줄에 거쳐 각 액자의 크기 $C_{j}(1 <= C_{j} <= 10^9)$이 주어집니다.

## 출력

첫 번재 줄에 알고박물관이 전시할 수 있는 최대 작품의 수를 출력합니다.

## 풀이

만약 전시를 한다면 어떤 액자들을 사용하는 것이 좋을까? 5개의 액자가 크기가 큰 순서대로 놓여있을 때, 실제론 3개의 그림을 각각 첫번째, 네번째, 다섯 번째 액자에 넣는다고 해보자. 그렇다면 이 때, 네번째 그림과 다섯 번째 그림을 각각 두번째, 세번째 액자에 넣을 수는 없을까? 현재 액자는 크기 순서대로 정렬되어있기 때문에 위처럼 옮기는 일은 항상 가능하다. 즉, 답이 어떻게 되든 간에 우리는 항상 액자를 가장 큰 액자부터 써도 무방하다는 것을 알 수 있다.
 
또한, 항상 액자에 들어가는 그림은 가치가 큰 것에서 작은 것으로 작아져야하기 때문에, 그림도 가치가 내림차순이 되도록 정렬을 해줄 수 있다. 
여기에서, 우리는 다음에 해당하는 값을 구해볼 수 있을까?
F[i, j] = (i번 그림까지 봤을 때, j번 액자까지 넣을 수 있는 그림의 최대 개수)
만약 위 식을 모든 i, j에 대해 답을 알게된다면, N번 그림까지 봤을 때 M번 액자까지 넣을 수 있는 그림의 최대 개수가 곧 우리가 구하고자 하는 답이므로, F[N, M]이 답임을 알 수 있다.
그러면 어떻게 F[i, j]를 구할 수 있을까?
만약 1~i, 1~j까지의 F[i, j]가 다 구해져있고, F[i, j]만 구하지 못한 상태라면 어떻게 할 수 있을까?
특히 이 때, i번 그림을 j번 액자에 넣을 수 없다면, F[i, j]는 어떻게 될까?
이 때는 항상 두 가지 경우가 있을 수 있을 것이다, 1~i-1번 그림들을 j번 액자까지 넣었을 수도 있고, 혹은 1~i번 그림들을 j-1번 액자까지에 넣었을 수도 있다(다른 모든 경우는 이 두 경우 중 하나에 포함된다). 위 두 경우를 통해 우리는
F[i, j] = MAX(F[i – 1, j], F[i, j – 1]) 이 된다는 것을 알 수 있다.
그렇다면, 만약 i번 그림을 j번 액자에 넣을 수 있다면 어떻게 될까? 이 때에는 1~i-1번을 1~j-1번 액자에 넣고, i번 그림을 j번 액자에 넣을 수도 있기 때문에 앞선 경우에 하나를 더 추가해줘야 한다. 즉, 이를 통해 F[i, j]는
F[i, j] = MAX(F[i – 1, j – 1] + 1, F[i – 1, j], F[i, j – 1])
이 된다.
우리는 결국 모든 i, j에 대해서 F[i, j]를 구해줄 수 있고, 답은 F[N, M]이 될 것이다. 이 때, F[N, M]을 구하는데 걸리는 시간은 모든 i, j를 계산하는 시간과 같으므로, 총 O(NM)이 된다.

## 풀이 - 최적화

위 방법을 문제의 특수한 성질을 통해 더 빠르게 계산할 수 있을까?
만약 정렬을 한 이후, 첫 액자에 하나의 그림을 넣어야 한다면, 어떤 그림을 넣는 것이 좋을까? 당연히 그 액자에 넣을 수 있는 최대 가치를 가진 그림을 넣어야 할 것이다. 이 때, 1번 액자에 넣은 그림을 i번이라고 한다면, 2번 액자에 1~i-1번에 있는 그림을 넣을 수 있을까? 이는 특별전시의 두 번째 조건인 항상 가치가 낮은 순서가 되어야한다는 것을 만족하지 못하므로, i번 그림을 첫 액자에 넣고 나면, 2번 액자에 넣을 수 있는 그림은 항상 i+1번 이후의 그림이 된다.
 
그림을 항상 증가하는 방향으로만 보게 됨
즉, 우리는 앞에서부터 그림을 살펴보면서 액자에 넣게 된다면, 그 이후에도 항상 다음 그림들만 보면 된다는 것을 알 수 있다. 여기서 액자에 넣는 조건은 항상 넣을 수 있는 크기이기만 하면 되므로(가치순서로 정렬되어있으므로) 앞에서부터 순서대로 그림을 보면서 액자에 넣어주는 것으로 문제를 해결할 수 있어, 전체 시간복잡도는 정렬은 하는데 걸리는 시간인 O(NlgN + MlgM)이 된다.
이 때 추가로, 같은 가치를 가지는 그림들은 항상 크기가 큰 순서가 앞에 오도록 정렬하면, 액자에 넣는 순서가 변하지 않게 되어 항상 답을 구할 수 있다.

# [JNEXT - spoj](https://www.spoj.com/problems/JNEXT/)

주어진 문제가 영문이기 때문에 번역을 하여 문제를 첨부하겠습니다.

## 문제

민성이는 누구보다 수를 좋아한다. 그 중에서도 특히 큰 수를 좋아한다. 그래서 N개의 자릿수가 주어지면, 이것을 이어붙여 하나의 큰 수를 만든다.

이를 지켜보던 성희는 놀라운 사실을 알아낸다. 민성이가 큰 수를 만든 것은 맞지만, 그것은 N개의 자릿수들을 이용해 만들 수 있는 ‘가장 큰 수가 아니었던 것’이다.
가장 큰 수를 만들어 알려주는 것은 민성이한테 너무 가혹한 일이기 때문에, 성희는 그 자릿수들을 이용해 만들 수 있는 모든 수들 중, 민성이가 만든 수보다 큰 수들 중, 가장 작은 수를 만들어, 더 큰 수가 있음을 민성이한테 알려주려 한다.

성희가 민성이한테 알려줄 수가 무엇일지 구해보자.

## 예시

7개의 자릿수 7, 1, 1, 3, 5, 2, 1이 있고, 민솔이가 이를 이용해 7113521 을 만들었다면, 동규는 7, 1, 1, 3, 5, 2, 1로 만들 수 있는 수들 중, 민솔이가 만든 것보다 큰 수 중 가장 작은 수인 7115123을 알려준다.

## 입력

첫 번째 줄에는 테스트 케이스의 수 t(1 <= t <= 100)가 주어집니다. 두 번째 줄부터 t개의 테스트 케이스가 차례로 주어지는데, 각 테스트 케이스의 첫 번째 줄에는 숫자의 자릿수 n(1 <= n <= 1000000)이 주어지고, 두 번째 줄에는 민성이가 만든 n자리 수의 각 자릿수가 공백을 사이에 두고 주어집니다.

## 출력

t개의 줄에 걸쳐서 각 테스트 케이스에 대해 성희가 민성이한테 알려줄 수를 출력합니다. 단, 민성이가 만든 수가 가장 큰 수일 경우 성희가 더 큰 수를 만드는 것이 불가능하므로 -1을 출력합니다.

## 관찰

먼저 가장 쉬운 방법을 생각해봅시다. N개의 자릿수가 있다면, 이를 나열하여 만들 수 있는 모든 수들을 직접 만들어보아 민성이가 만든 수와 비교할 수 있습니다. N개를 나열하는 경우의 수는 모두 N! 만큼의 경우가 생기게 됩니다.
만약 N이 10보다 작다면, 10! = 3,628,800이기 때문에 이를 이용해 만들 수 있는 수는 아무리 많아도 500만개를 넘지 않아, 이를 직접 정렬해보는 것으로 해결할 수도 있을 것입니다.

하지만 N!은 매우 크게 증가하는 수입니다. 즉, N이 조금만 커져도 기하급수적으로 실행시간이 늘어나게 되어 다른 방법을 찾아봐야합니다.

그렇다면, N이 매우 커서 만들 수 있는 수가 굉장히 많은데도 어떻게 성희가 원하는 수를 찾을 수 있을까요? 그 실마리는 민성이가 만든 수보다 큰 수는 매우 많을 수 있지만, 우리가 필요로 하는 수는 그 수들 중 ‘가장 작은 수’ 하나에만 해당한다는 사실에 있습니다.

위의 예시를 봅시다. 민성이가 7113521을 만들고, 성희는 7115123을 만들었습니다. 이 때, 성희가 만든 수와 민성이가 만든 수 중, 변하지 않은 부분을 볼 수 있을까요?
성희가 천의 자리 숫자를 1 이상 증가시켜 값을 더 크게 만들었습니다. 이 때, 만의 자리 이상의 자릿수들은 더 크게할 경우 현재 성희가 만드는 숫자보다 커지게 되고, 더 작게하면 민성이가 만든 수보다도 더 작게 됩니다. 즉, 우리가 **변화시키려는 최대 자릿수보다 더 큰 자리의 수들은 바꾸어도 절대 우리가 원하는 답이 될 수 없습니다.**

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_5_7.PNG)

처음 주어진 문제는 7개의 자릿수를 이용하는 문제였지만, 위의 관찰을 통해 우리는 711을 고정시켜야함을 통해, 3521을 5123으로 바꾸는 문제로 바꿀 수 있었습니다.

그렇다면, 천의 자리를 고치지 않고, 백의 자리까지만 고쳐 답을 구할 수 있을까요? 아까의 관찰을 이용하면, 우리는 3도 고정시키게 되어 521보다 더 큰 수를 만드는 문제로 바뀌게 됩니다. 하지만 5, 2, 1을 이용하여 521보다 더 큰 수는 만들 수가 없습니다.
왜냐하면, 521은, 5, 2, 1 중 가장 큰 자릿수부터 가장 큰 자릿수에 넣어 만들었기 때문입니다.
즉, 특정 자릿수까지 내림차순으로 이루어졌을 경우, 이보다 더 큰 수는 만들 수 없습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_5_8.PNG)

결국, 우리는 **내림차순을 만족하지 않는 최소의 자릿수를 찾아 그보다 더 큰 최소의 수를 만드는 것**으로 문제를 해결할 수 있게 됩니다.

## 풀이

우리는 관찰을 통해, 더 이상 내림차순을 만족하지 않게 되는 최소의 자릿수를 찾아 값을 변화시켜야 한다는 것을 알게 되었습니다. 이는 1의 자릿수부터 시작해, 현재 자릿수보다 다음 자릿수의 값이 작게 되는 최초의 자릿수를 찾는 것으로 찾아낼 수 있습니다. 그렇다면, 그 아래의 자릿수들을 이용해 민성이의 값보다 큰 가장 작은 값은 어떻게 만들 수 있을까요?

변화시켜야하는 자리의 위치를 오른쪽에서부터 세었을 때, i번 위치라고 합시다. 그러면 i번 위치의 값은, 1 ~ i-1번 위치의 값들 중 i번 위치보다 크며, 나머지 값들 보단 가장 작은 값을 이용해 만들어야합니다(그보다 더 큰 값을 이용하면, 항상 더 작게 만들 수 있으므로). 편의상, 이 때의 위치를 j라고 합시다. 이제 i번 값과 j번 값을 바꾸어주면, 1 ~ i-1번 값들이 어떻게 배치돼도 항상 민성이의 수보다 커지게 됩니다. 즉, 우리는 남은 수를 이용해 가장 작은 수를 만들어주면 되므로, 값이 작은 순서대로 i-1번 위치부터 채워주면 됩니다.

위에 설명한 내용은, 스택의 ‘원소들의 들어오고 나가는 순서가 유지된다’는 성질을 이용하면 좀 더 깔끔하게 구현할 수 있습니다.

- 2개의 스택을 준비합니다.
- 1의 자리 자릿수부터 차례대로 1번 스택에 넣으며, 스택의 가장 위에 있는 수가 현재 보고있는 자릿수(편의상 i번 자릿수라 사용)보다 커질 때까지 넣어줍니다.
- 1번 스택의 탑에 있는 수가 i번 자릿수보다 크지 않을 때까지, 1번 스택의 탑을 2번 스택으로 옮겨줍니다.
- i번 자릿수를 1번 스택으로 옮기고, 2번 스택의 탑을 i번 자릿수로 옮깁니다.
- 1번 스택을 모두 2번 스택으로 옮깁니다.
- 2번 스택에 있는 값들을 순서대로 i-1~1번 자릿수로 옮깁니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_5_9.PNG)

스택에 들어가는 원소들은 항상 오름차순, 혹은 내림차순의 정렬순서가 유지되기 때문에, 위와 같이 1번 스택은 오름차순, 2번 스택은 내림차순 순서로 원소를 넣어주는 것으로 쉽게 구현할 수 있습니다.

그렇다면 -1을 출력하는 경우는 어떻게 알 수 있을까요?

애초에 주어진 자릿수에 사용된 수들이 내림차순으로 정렬되어있다면 가장 큰 수에 해당한다는 사실을 알 수 있습니다. 이것을 처음에 예외를 통해 처리해주는 것이 가능합니다.
혹은 우리가 구현한 과정에서 위 조건을 만족한다면, 스택에는 모든 수들이 다 들어가게 되므로 모든 수를 조건에 맞게 스택에 넣는 것이 가능하다면 -1을 출력하는 식으로 처리해주셔도 됩니다.

스택을 사용하지 않는 방법으로는, 큐를 이용하여도 구현할 수 있습니다. 동작 원리는 스택과 비슷하게 할 수 있으므로 사용하기 더 편한 자료구조를 사용해주시면 됩니다.

# 코드

## 두 배열의 합 - 풀이 1

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int T, n, m, ncnt, mcnt;
ll res;
int A[1010], B[1010], Aarr[1000010], Barr[1000010];

int main(){
	int i, j, c, d, sum;
	scanf("%d", &T);
	scanf("%d", &n);
	for(i = 0; i < n; i++) scanf("%d", &A[i]);
	scanf("%d", &m);
	for(i = 0; i < m; i++) scanf("%d", &B[i]);
	for(i = 0; i < n; i++){
		sum = 0;
		for(j = i; j < n; j++){
			sum += A[j];
			Aarr[ncnt++] = sum;
		}
	}
	for(i = 0; i < m; i++){
		sum = 0;
		for(j = i; j < m; j++){
			sum += B[j];
			Barr[mcnt++] = sum;
		}
	}
	sort(Aarr, Aarr + ncnt);
	sort(Barr, Barr + mcnt);
	i = 0; j = mcnt - 1;
	while(i < ncnt){
		c = i + 1;
		while(c < ncnt && Aarr[c] == Aarr[i]) c++;
		while(j >= 0 && Barr[j] + Aarr[i] > T) j--;
		if(j < 0 || Barr[j] + Aarr[i] != T){ i = c; continue; }
		d = j - 1;
		while(d >= 0 && Barr[d] == Barr[j]) d--;
		res += 1ll * (c - i) * (j - d);
		i = c; j = d;
	}
	printf("%lld", res);
	return 0;
}
```

## 두 배열의 합 - 풀이 2

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int T, n, m, ncnt, mcnt;
ll res;
int A[1010], B[1010], Aarr[1000010], Barr[1000010];

int main(){
	int i, j, c, d, sum;
	scanf("%d", &T);
	scanf("%d", &n);
	for(i = 0; i < n; i++) scanf("%d", &A[i]);
	scanf("%d", &m);
	for(i = 0; i < m; i++) scanf("%d", &B[i]);
	for(i = 0; i < n; i++){
		sum = 0;
		for(j = i; j < n; j++){
			sum += A[j];
			Aarr[ncnt++] = sum;
		}
	}
	for(i = 0; i < m; i++){
		sum = 0;
		for(j = i; j < m; j++){
			sum += B[j];
			Barr[mcnt++] = sum;
		}
	}
	sort(Barr, Barr + mcnt);
	for(i = 0; i < ncnt; i++){
		res += upper_bound(Barr, Barr + mcnt, T - Aarr[i]) - lower_bound(Barr, Barr + mcnt, T - Aarr[i]);
	}
	printf("%lld", res);
	return 0;
}
```

## JNEXT

```cpp
#include <bits/stdc++.h>
using namespace std;

int T, n;
int arr[1000010];
char rarr[1000010];
stack <int> st, st2;

int main(){
	int p, i;
	scanf("%d", &T);
	for(p = 1; p <= T; p++){
		scanf("%d", &n);
		for(i = 0; i < n; i++) scanf("%d", &arr[i]); st.push(-1);
		for(i = n - 1; i >= 0; i--){
			if(st.top() <= arr[i]) st.push(arr[i]);
			else{
				while(st.top() > arr[i]) st2.push(st.top()), st.pop();
				st.push(arr[i]);
				arr[i++] = st2.top();
				st2.pop();
				while(!st.empty()) st2.push(st.top()), st.pop(); st2.pop();
				while(!st2.empty()) arr[i++] = st2.top(), st2.pop();
				break;
			}
		}
		if(i == -1) printf("-1\n");
		else{
			for(i = 0; i < n; i++) rarr[i] = '0' + arr[i];
			rarr[n] = 0;
			printf("%s\n", rarr);
		}
		while(!st.empty()) st.pop();
		while(!st2.empty()) st2.pop();
	}
	return 0;
}
```
