---
layout: post
title: "CORDIC(Volder's Algorithm)"
date: 2021-05-18 22:00:00
author: psb0623
tags:
---

자주 있는 일은 아니지만, 살면서 적어도 한 번쯤은 삼각함수를 사용하는 코드를 작성해야 할 일이 있을 것입니다. C++의 [math.h](https://www.cplusplus.com/reference/cmath/) 헤더나 Python의 [math](https://docs.python.org/ko/3/library/math.html) 모듈같이, 대부분의 언어에서 삼각함수를 비롯한 여러 기능을 지원하는 수학 라이브러리가 기본으로 제공됩니다.

```python
>>> from math import *
>>> sin(1) # usage of sin function in Python
0.8414709848078965
```

그런데, 주어진 각도가 $ \pi/6 $, $\pi/4$, $\pi/3$과 같이 딱 떨어지는 특수각이 아닐 때에도 컴퓨터는 어떻게 삼각함수의 값을 구할 수 있는 걸까요? 위 예시에서 $\sin 1$의 값은 도대체 어떤 과정을 통해 얻어진 걸까요?

## 근사값 구하기

사실 특수각이 아닌 경우 삼각함수의 값을 정확히 구하기란 불가능합니다. 대신, 여러가지 근사 기법을 이용해 실제 값에 매우 가까운 근사값을 계산해내는 것입니다. 대표적인 예시로, 수학에 관심이 있는 분이라면 아래와 같은 [테일러 급수](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%9D%BC%EB%9F%AC_%EA%B8%89%EC%88%98)를 이용해서 삼각함수의 값을 꽤 정확하게 근사해낼 수 있다는 것을 알고 계실 것입니다.

$$ \sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots $$

$$ \cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \cdots $$

자세한 설명은 생략하겠지만, 위 급수는 빠르게 수렴하며 실제로 사용하기에도 무리가 없습니다. 하지만 꼭 이것만이 유일한 방법인 것은 아닙니다.

이번 글에서는 삼각함수의 값을 구할 때 쓰이는 또 다른 전통적인 근사 알고리즘인 **CORDIC**에 대해 알아보도록 하겠습니다.

CORDIC이란 **CO**ordinate **R**otation **DI**gital **C**omputer의 약자로, 말 그대로 좌표의 회전을 이용해 값을 계산해내는 알고리즘입니다. 좌표의 회전이라는 특성 상, CORDIC에서는 2차원에서의 회전 변환 행렬이 중요한 역할을 합니다.

## 회전 변환 행렬

어떤 2차원 벡터 $(x,y)$를 원점 기준 반시계 방향으로 $\theta$만큼 회전시키는 행렬 $R_{\theta}$는 아래와 같이 표현됩니다.

$$ R_{\theta} = \begin{bmatrix} {\cos \theta} & {-\sin \theta} \\ {\sin \theta} & {\cos \theta} \end{bmatrix} $$

예를 들어, 

또한, 어떤 점을 $\theta_1$만큼 회전시킨 후 다시 $\theta_2$만큼 회전시킨다면, 결과적으로 $\theta_1 + \theta_2$만큼 회전시킨 것이 되므로 회전 변환 행렬의 곱으로 또 다른 회전 변환 행렬을 나타낼 수 있습니다.

$$ R_{\theta_1} \cdot R_{\theta_2} = R_{\theta_1 + \theta_2} $$

## 아이디어

회전 변환 행렬을 이용하여, 다음과 같은 아이디어를 생각할 수 있습니다.

초기 벡터 $v_0 = (1,0)$을 잡습니다.

$v_0$의 각도가 목표 벡터보다 작으므로, $\pi/4$만큼 회전시킵니다.

그러면 새로운 벡터 $v_1 = R_{\frac{\pi}{4}} v_0 $가 됩니다.

이제 $v_1$을 보면, 여전히 목표 벡터보다 작으므로 $\pi/8$만큼 회전시킵니다.

그러면 새로운 벡터 $v_2 = R_{\frac{\pi}{8}} v_1$이 됩니다.

이제 $v_2$의 각도가 목표 각도보다 더 커졌으므로, 이번에는 $-\pi/16$만큼 회전시킵니다.

그러면 새로운 벡터 $v_3 = R_{-\frac{\pi}{16}} v_2$이 됩니다.

이 과정을 계속 반복하다 보면...



$v_n$의 각도가 원하는 각도 $\theta$에 매우 가까워질 것임을 직관적으로 알 수 있습니다.

$n$번 반복했을 때, $v_n$의 각도와 목표 각도 $theta_n$ 사이의 차이는 \frac{\pi}{2^{n+1}}보다 작으므로, 

따라서, R_pi/4, R_-pi/4, R_pi/8, R_-pi/8 의 값을 [-pi/2, pi/2]에 속하는 각도 $\theta$에 대해 효과적으로 cos theta와 sin theta를 근사할 수 있습니다.


## CORDIC 구현

실제 CORDIC에서는  더 효율적인 계산을 위해 

## CORDIC 증명

대충 무슨 느낌인지는 

수학적 귀납법을 통해, theta_n과 목표 각의 차이는 gamma_n보다 작고, lim gamma_n = lim arctan(-2^n) = arctan ( lim -2^n) = arctan(0) = 0 이므로 목표 각도에 수렴함을 보일 수 있습니다.  






## 예시 

고정소수점 방식을 사용할 때 이점이 있습니다.

## References

[https://en.wikipedia.org/wiki/CORDIC](https://en.wikipedia.org/wiki/CORDIC)
