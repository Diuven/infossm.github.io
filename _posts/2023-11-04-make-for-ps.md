---
layout: post
title: "문자열 해싱"
date: 2023-11-27
author: red1108
tags: [hashing, string, rolling hash, rabin-karp]
---


> 이번 글에선 해싱의 다양한 활용을 정리하고자 한다. 너무 기본적인 내용이나 필자도 모르는 너무 고급 기술은 다루지 않고, 다이아 중하위 수준까지의 문제를 해싱을 이용해 풀어보려는 사람들에게 적합하다. 해시값을 관리하는 몇가지 방법들을 소개하고, 마지막으로는 며칠 전에 출제된 따끈따끈한 문제인 ICPC 2023 Seoul Regional에 출제된 E번 문항을 해싱을 써서 해결하는 방법을 소개하며 글을 마무리한다.
# 해싱이란?

문자열 x[0] ~ x[l-1] 이 주어져있을 때, 소수 $p, M$을 사용하여 계산한 해시값 $(\sum_{i=0}^{l-1} x_ip^i) \text{ mod M}$ 을 비교하여 다른 문자열과 동일성을 판정하는 기법이다.

여기까지의 정의로는 $p$와 $M$이 꼭 소수일 필요는 없지만, 나중에 설명할 다양한 기법들까지 발전시키기 위해서라면, 그리고 저격데이터로 인해 틀릴 확률을 줄이기 위해서라면 $p$와 $M$이 소수여야만 한다.

## 해싱의 활용

문자열 매칭에 사용한다. 일일이 두 문자열의 동일성을 판정하려면 $O(l)$에 비례하는 시간복잡도가 필요하지만, 해시값이 미리 구해져 있다면 $O(1)$ 시간에 비교할 수 있다.

다들 알겠지만, 해싱도 치명적인 단점이 있다. 실제로는 다르지만 해시값이 같은 두 문자열을 저격 데이터로 만들 수 있고, 너무 흔한 $p$와 $M$쌍을 사용하면 저격당할 수 있다. 특히 코드 hack이 가능한 코포라면 당신이 쓴 $p, M$쌍에 알맞는 저격데이터를 생성할 수도 있으므로 더 위험하다. 하지만 미리 채점 데이터가 확정되어 있다면 $p, M$을 적당히 바꿔보고 더블 해싱까지 사용하면 웬만해서는 틀리기 힘들다.

물론 대회에서 나온 문자열 문제에서 해싱이 정해인 경우는 거의 없다. 보통 사용되는 알고리즘으로는 kmp, 아호 코라식, suffix array 같은 좋은 방법들이 있지만, 고난이도의 문제라면 이 알고리즘들을 알고 있더라도 문제 풀이가 바로 나오지 않는 경우가 많다. 그리고 대회에선 이러한 고민에 시간을 쓰는 것 조차 큰 손해인 경우가 많고, 해싱을 쓰면 크게 머리를 쓰지 않고 문제가 풀리는 경우가 있다. 따라서 해싱을 적당히 알아두면 좋다.
## 해시값 관리

해싱으로 시간적인 이득을 보려면 주어진 문자열 s[0] ~ s[n-1]에서 s[l] \~ s[r] 의 해시값을 빠르게 구하는 것이 중요하다. 상황에 따라 다양한 전략이 가능하다.

해시값을 정의하는 방법은 크게 두 가지 방법이 있는데,

$$(\sum_{i=0}^{l-1} x_ip^i) \text{ mod M}$$

이렇게 정방향 순서와,

$$(\sum_{i=0}^{l-1} x_ip^{l-1-i}) \text{ mod M}$$

이렇게 역방향으로 계산하는 해싱이 있다 있다. 롤링 해싱을 [0] -> [l-1] 순서로 진행하는 경우엔 역순으로 하는 해싱이 모듈러 역원을 사용하지 않아서 조금 더 간단하지만, 큰 차이는 없다. 따라서 이번 글에서는 $(\sum_{i=0}^{l-1} x_ip^i) \text{ mod M}$ 이렇게 계산하는 정방향 해싱을 기준으로 설명하도록 하겠다.
### 1. $r-l$ 이 일정한 경우: rolling hashing

라빈 카프 알고리즘에서 사용하는 제일 기본적인 해싱 기법이 롤링 해싱이다. 길이 r-l인 문자열을 밀면서 해시값을 구한다.


<p align="center"><img src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F944f7fba-608a-4202-b7f9-057d6a35eab3%2FUntitled.png&blockId=5582bc47-5c25-46b2-9220-e6c9197e9ea4"></p>
<center><b>그림 1. 슬라이딩 윈도우 기법으로 일정한 길이 부분문자열의 해시값 계산</b></center>

부분문자열의 길이 $k = r-l+1$로 정의하고, i를 0부터 n-1까지 밀면서 s[i-k+1] ~ s[i]의 해시값을 구하려는 상황을 가정하자. 이전의 해시값은 s[i-k] ~ s[i-1] 까지의 해시값을 담고 있을 것이다. 이 값을 A라고 하면, 새로운 해시값은 

$$\frac{A-s_{i-k}}{p}+s_ip^{k-1}$$

이 될 것이다. 물론 모든 값은 **M으로 나눈 나머지** 로 관리되므로, $p^{-1} = p^{M-2}$ 로 정의한 뒤, 

$$A' = ((A-s_{i-k})p^{-1}+s_ip^{k-1})\text{ mod M}$$

을 계산하여 갱신할 수 있다. 실제 코드에선 $A'$이 값이 음수가 되는 것을 방지하기 위해

```c++
A = (A - s[i-k]) * INVP % mod;
A = (A + s[i] * mypow(p, k-1)%mod)%mod
A = (A + mod)%mod // 이 부분 중요
```

위 코드처럼 $M$을 더한 다음 다시 $M$으로 나눈 나머지를 구해야만 한다. TLE를 피하려면 mypow함수는 아래와 같이 로그 시간에 작동하는 함수여야만 한다.

```c++
typedef long long ll;
ll mypow(ll a, ll b) {
    ll ret = 1;
    while(b) {
        if(b&1) ret = ret*a%mod;
        a = a*a%mod;
        b>>=1;
    }
    return ret;
}

// 이걸 써서 ll INVP = mypow(p, mod-2)로 계산하자.
```

불필요한 **시간 초과**를 피하기 위해서 해시값을 계산하는 과정에서 매번 mypow를 호출하지 말고, 미리 배열에 $p$와 $p^{-1}$거듭제곱을 전부 구해놓고 꺼내 쓰는 방법을 강력하게 추천한다. 간단한 문제라면 상관 없지만, modular 연산은 아주아주 느리기 때문에 웬만하면 미리 구해놓아야만 한다.

여튼 이렇게 하면 $r-l$이 일정한 경우에 쓸 수 있는 롤링 해싱을 구현할 수 있다.

### 2. $r-l$ 이 일정하지 않은 경우: prefix hashing

이제 더 나아가 $r-l$이 일정하지 않고 가변적인 길이의 부분문자열의 해시 값을 구해야 하는 경우를 살펴보자. 이전보다 오히려 간단하다고 느낄 수도 있다.

y[i] 에 s[0] ~ s[i] 까지의 해시값을 저장하자. 다음과 같은 형태일 것이다.

$$y_i = (\sum_{j=0}^{i}s_jp^j)\text{ mod M}$$

이 값은 누적합의 개념을 사용해서

```c++
for (int i=0; i<n; i++)
    y[i] = (y[i-1] + s[i]*mypow(p, i))%mod
```

이런식으로 구해놓을 수 있다. 그리고 s[l] ~ s[r] 까지의 해시값은 $(y[r]-y[l-1]) / p^{l-1}$ 로 쉽게 계산할 수 있다. 사실 아무리 생각해 봐도 이 방법이 롤링 해싱보다 훨씬 간단하면서도 상위호환인 방법인 것 같다.
### 3. 문자열 s가 갱신되는 경우: segment tree

문자열 s의 원소를 바꾸는 쿼리와 s[l] ~ s[r]까지의 해시값을 구하는 쿼리를 온라인으로 쉽게 처리할 수 있는 방법이 있다. q개 쿼리, 문자열의 길이가 n이라면 $O(qlogn)$에 가능하다.

## 응용: ICPC 2023 E번

이번 ICPC 2023 E번 문항이 해싱으로 풀리는 문제였다. 정해는 아호 코라식을 잘 응용하면 풀리는 것 같은데, 아마 대부분의 사람들에게는 1. 대회시간 내에 이 풀이를 떠올리고 2. 수정된 아호 코라식을 실수 없이 구현하는것 보단 해싱으로 문제를 해결하는게 편하리라 생각한다.

### 문제 설명

간단하게 문제를 설명하자면, 

> 길이 N(< 백만)인 중복 없는 수열이 주어진다. 그리고 길이 K(< 10000)인 패턴 M(< 1000)개가 주어지는데, 이 턴은 상대적인 수들의 순서를 나타내며, 1과 K사이 수들로 이루어진 permutation이다. 패턴들은 모두 다르다. 이 때, 처음에 주어진 길이 N인 수열을 앞에서부터 볼 때, 최초로 상대적인 수들의 크기 순서가 패턴과 가장 먼저 일치하는 패턴을 찾자.

예를 들어, 수가 10, 50, 20, 30, 40 이고, 첫 패턴은 3, 1, 2. 두 번째 패턴은 1, 2, 3 이라고 하자. 이 경우 답은 3, 1, 2 이다. 수열에서 두번째 원소부터 시작하는 [50 20 30] 부분이 패턴과 일치하기 때문이다. 패턴 1, 2, 3은 맨 마지막 [20 30 40]에서 등장하므로 등장 순서 상에서 밀렸다.

### 해싱을 사용한 풀이

상대적인 크기를 해싱해야 하므로 바로 해시값에 넣을 수가 없다.