---
layout: post
title: "문자열 해싱"
date: 2023-11-27
author: red1108
tags: [hashing, string, rolling hash, rabin-karp]
---



# 해싱이란?

$x_ip^i$ 더함

## 해싱의 활용

당연히 문자열 매칭에 사용. 동일성을 정확히 확인하는데 시간이 오래 걸리는 작업을, 약간의 저격 데이터의 리스크를 감수하고 O(1) 비교로 빠르게 만드는 것이 해싱의 목적이다. 대표적으로 라빈 카프 알고리즘이 있고, 주로 문자열 문제에서 사용된다. 문자열에도 kmp, 아호 코라식, suffix array 같은 좋은 방법들이 있지만, 고난이도의 문제라면 이 알고리즘들을 알고 있더라도 문제 풀이가 바로 나오지 않는 경우가 많다. 그리고 대회에선 이러한 고민에 시간을 쓰는 것 조차 큰 손해인 경우가 많고, 해싱을 쓰면 크게 머리를 쓰지 않고? 문제가 풀리는 경우가 있다. 따라서 해싱을 조금 알아두면 좋다.

## 해시갑 관리

기본적으로 문자열 s[0] ~ s[n-1] 이 주어질 때, s[l] ~ s[r] 의 해시값을 빠르게 구하는 것이 중요하다. 상황에 따라 다양한 전략이 가능하다.

### $r-l$ 이 일정한 경우 -> rolling hashing

라빈 카프 알고리즘에서 제일 기본적인 해싱 기법이 롤링 해싱이다. 문자열을 밀면서 해시값을 구한다.

### $r-l$ 이 일정하지 않은 경우 -> prefix hashing

$s_ip^i$의 누적합을 구하고 뒤에서 앞을 뺀다. 모듈러 역원을 써야 한다.

### 문자열 s가 갱신되는 경우 -> segment tree

상상하는 그거

## 응용: ICPC 2023 E번

이번 ICPC 2023 E번 문항이 해싱으로 풀리는 문제였다. 정해는 아호 코라식을 잘 응용하면 풀리는 것 같은데, 아마 대부분의 사람들에게는 1. 대회시간 내에 이 풀이를 떠올리고 2. 수정된 아호 코라식을 실수 없이 구현하는것 보단 해싱으로 문제를 해결하는게 편하리라 생각한다.

### 문제 설명

간단하게 문제를 설명하자면, 

> 길이 N(< 백만)인 중복 없는 수열이 주어진다. 그리고 길이 K(< 10000)인 패턴 M(< 1000)개가 주어지는데, 이 턴은 상대적인 수들의 순서를 나타내며, 1과 K사이 수들로 이루어진 permutation이다. 패턴들은 모두 다르다. 이 때, 처음에 주어진 길이 N인 수열을 앞에서부터 볼 때, 최초로 상대적인 수들의 크기 순서가 패턴과 가장 먼저 일치하는 패턴을 찾자.

예를 들어, 수가 10, 50, 20, 30, 40 이고, 첫 패턴은 3, 1, 2. 두 번째 패턴은 1, 2, 3 이라고 하자. 이 경우 답은 3, 1, 2 이다. 수열에서 두번째 원소부터 시작하는 [50 20 30] 부분이 패턴과 일치하기 때문이다. 패턴 1, 2, 3은 맨 마지막 [20 30 40]에서 등장하므로 등장 순서 상에서 밀렸다.

### 해싱을 사용한 풀이

상대적인 크기를 해싱해야 하므로 바로 해시값에 넣을 수가 없다.