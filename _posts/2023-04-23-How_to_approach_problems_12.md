---
layout: post
title:  "알고리즘 문제 접근 과정 11"
date:   2022-09-18 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 11

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

JOI 기출문제들 중 한글로 번역이 되어있지 않고, 한글 풀이가 존재하지 않는 문제들 위주로 풀이를 작성하려고 합니다.
이번 문제들의 난이도는 기존 시리즈들과는 달리, 기출문제들 중 높은 번호의 문제들을 다루다보니 조금 어렵게 느껴질 수 있습니다.

그럼에도 가장 낮은 단계부터 차근차근 접근하는 과정을 보여드려, 이해하시는 데 어려움이 없도록 설명하겠습니다.

# [Sugar Glider - JOI 2014 4번](https://www.acmicpc.net/problem/10048)

해당 문제에는 한글 번역이 존재하지 않습니다. 그러나 일본어의 경우 한글 번역이 꽤나 잘 동작하기 때문에, JOI 문제도 번역을 사용하여 문제 상황을 이해하기 편하실 겁니다.

실제 저의 경우에도, 번역이 되지 않은 JOI 문제들을 해결할 때에, 영문 번역이 존재하지 않는 경우 번역기를 사용하여 문제를 파악하였습니다.
전체적인 문제 상황을 파악하는 것에 큰 어려움이 없으실 것이므로 이와 같은 방법으로 JOI 문제들도 해결해보시면 좋습니다.
JOI 문제들의 퀄리티가 높기 때문에 한 번 즈음 다 해결해보시는 것도 좋은 방법입니다.

전체적인 문제 상황은 간단히 다음과 같습니다.

## 문제 상황

N개의 나무가 있으며, 각각 i번 나무는 높이 $h_{i}$ m를 가지고 있습니다. 이 때, M개의 나무 쌍에 대해서는 날아서 다른 나무로 이동하는 것이 가능합니다.
이 때, j번 나무 쌍 사이를 날아서 이동할 때에 걸리는 시간은 $t_{j}$초이며, 날아가는 동안에는 1초마다 높이가 1m씩 줄어들게 됩니다.
이렇게 날아가는 도중에 나무에 도착하기 전에 높이가 0이하가 되거나, t초를 날고 나서도 해당 나무의 높이보다 더 높게 존재하는 경우에는 이동할 수 없습니다.

JOI군은 처음에 1번 나무의 X미터 높이에 있으며, 날아서 N번 나무의 꼭대기로 이동하고 싶습니다.
JOI군이 각 나무에서 1초 동안 1m를 올라가거나 내려갈 수도 있을 때, N번 나무의 정상으로 이동하기 위해 얼마의 시간이 걸리는지 알려주세요.

## 관찰

주어진 문제를 해결할 때에 가장 어려운 부분이 무엇일까요? 즉, 어떠한 제약 조건이 없다면 이 문제를 쉽게 해결할 수 있을까요?

문제를 파악하는 데에 가장 쉬운 방법은 바로 문제 자체를 단순하시키는 작업입니다. 만약 어떠한 단순화된 문제에서 우리가 풀이를 찾아낼 수 있다면, 다음과 같은 방법으로 나누어 문제를 해결할 수 있기 때문입니다.

- 문제의 제약 조건을 바꾸어 어떻게 단순화할 수 있는가
- 단순화된 문제에서 어떻게 문제를 해결할 수 있는가
- 실제 문제에서 제약 조건을 바꾸지 않고도, 위의 단순화된 해법을 적용할 방법이 있는가

해당 부분을 판단하기는 많은 경우에 어려움이 있을 수 있습니다. 예를 들어, 아예 특정 조건을 무시하거나 처리하는 것이 불가능하여 이러한 제약 조건을 바꾼 문제의 풀이가, 원 문제의 풀이와는 상관이 없는 경우가 그러한 예시입니다.

그러나 꽤나 많은 경우, 단순화된 문제에서의 풀이가 실제 원래의 문제에서도 사용되는 경우들이 종종 있습니다.

그러한 예시 중 하나가 바로 시작점, 혹은 끝점 등에서 좌표나 위치가 중첩되는 경우, 구간이 겹치는 경우 등에 해당하는 문제들이 그러합니다.
이러한 문제들 중 일부는 일단 주어진 쿼리들이 유니크하다는 전제 하에 문제를 해결해두고, 중첩 쿼리들을 묶어서 생각하는 등의 문제로 해결할 수 있는 경우가 많습니다.
(물론, 모든 것들은 케이스마다 다르기 때문에, 실제로 어떠한 접근이 유효할 것인지 파악하는 능력을 많은 문제들을 접하는 것으로 키우는 것이 중요합니다)

혹은 실제로 이러한 접근이 유효하지 않다고 하더라도, 해당 제약 조건이 '왜' 중요한지에 대해서 파악할 수 있다는 장점을 가지고 있습니다.

그렇다면 다시 돌아와서, sugar glider 문제에서는 어떠한 제약 조건이 가장 까다로울까요?

아마 다들 바로 파악하실 수 있으셨을 것입니다.
바로, **날아가고 난 후, 0~나무 높이 사이에 위치해야한다**라는 조건이 위 문제를 어렵게 만들고 있습니다.

위의 제약조건이 있을 때에 우리는 여러가지 경우로 나누어서 날아가는 것을 생각해줘야합니다.

- 현재 나무의 높이가 날아가는 거리보다 낮을 경우, 날아가는 것이 불가능합니다
- 현재 위치의 높이에서 날아간 후, 목표 나무의 높이보다도 높을 경우에는, 그 차이만큼 현재 나무에서 내려간 후 날아가야 합니다
- 현재 위치의 높이에서 날아간 후, 0 미만의 높이가 된다면, 그 차이만큼 현재 나무에서 올라간 후 날아가야 합니다

이러한 경우들을 따져주게 되어야, 목표 나무에서 0부터 h 사이의 높이 중 어느 높이에 존재하게 된다는 것입니다.

즉, 이 과정에서 어떠한 나무에서 어떠한 높이에 있는지를 고려하게 되는 경우, 어떤 경로로 이동할 때에는 그것보다 높은 상황으로 올라가야할 수도, 어떠한 경우엔 그보다 낮은 상황으로 내려가야할 수도 있기 때문에, 어떠한 높이에 있어야 최적이 되는지가 매 번 달라지게 됩니다.

이를 모두 고려하게 된다면, 각 나무마다 '해당 나무의 높이 x로 올 때까지 걸리는 최소 시간'에 대한 정보들을 기록하고 있어야되며, 이는 전체 나무의 수 N에 전체 나무의 가능한 높이 h를 곱한 값만큼을 모두 고려하는 경우로 볼 수 있게 됩니다.

해당 풀이를 직접 적용하는 경우에는, 전체 N x H에 해당하는 배열을 만들어 값을 채우는 것과 동시에, M개의 나무쌍에 대해서 각 현재 나무에서 H에 해당하는 높이들에 대해 도착할 때의 최적의 경우를 고려해줘야하는 M x H에 해당하는 경우를 따져줘야하기 때문에, 전체 시간복잡도 O((N+M) x H)가 걸리게 됩니다.

해당 방법으로 구현하는 경우, 주어지는 값들이 너무 크기 때문에 올바른 답을 구하기에 충분하지 않음을 알 수 있습니다.

## 풀이

그렇다면, 아까의 단순화를 고려하여 만약에 날아가고 나서도 어떠한 나무 높이에 있어도 된다고 생각해봅시다.
그 예시로, 모든 나무들이 높이도 무한하고, 땅 아래로 들어가는 것까지 유효하다고 생각한다면, 우리는 위 문제를 어떻게 해결할 수 있을지 생각해볼 수 있습니다.

이 경우, 우리는 앞서 이야기했던 불가능한 경우들을 모두 배제하고 문제를 생각해줄 수 있습니다.
우리는 이 경우, JOI군이 언제 올라가거나 내려가야하는지를 하나도 고려하지 않고, 그저 최종 상태에서 나무의 목표 높이에 오르기 위해 얼마를 이동해야하는지 고려하는 단순한 다익스트라 문제처럼 볼 수 있게 됩니다.

만약, 목표 상태로 이동한 이후 해당 높이보다 높다면 그 높이 차만큼 내려오고, 그렇지 않다면 그 차만큼 올라가는 방식으로 항상 N번 나무에서만 해당 상태를 고려해주어도 상관없다는 것을 알 수 있습니다.

만약에 중간에 이동하는 경우가 최적이 되는 경우가 존재하더라도, 같은 상황을 그저 마지막 나무에서 고려하는 것으로 바꾸는 것만으로 동일하게 해결이 가능하다는 것입니다.

이러한 제약 조건을 지우는 것은 정말로 문제를 쾌적하게 해결하게 해줍니다.

그렇다면, 이제는 해당 제약 조건을 넣었을 때에도, 우리가 앞서 단순화한 풀이를 적용할 수 있는 방법이 있는지 고려해주도록 합시다.


앞서서 문제를 단순화할 수 있었던 가장 큰 요인은 다음과 같습니다.

- 올라가거나 내려가는 것을, 마지막 나무에서만 고려해도 된다

그렇다면 위와 같은 상황만 고려해도 될 때, 왜 편하게 문제를 풀 수 있을까요?

이는 바로 **중간의 나무 상태들 중 어떠한 것이 최적인지 고려할 필요가 없다**라는 것에 있습니다. 우리는 앞서 관찰에서 생각한 풀이에서, 어떠한 높이에 있는 경우가 가장 좋은지 모두 고려하면서 문제를 해결하게 되었고, 이를 따지다보니 결국 H라는 높이들 중 어떠한 것이 최적인지 기록하게 되었습니다.

그러나 실제로 위 경우를 생각해보면, 중간에서는 내려가거나 올라가지 않아도 된다는 것 따지게 되었을 때, 어떠한 경우만 고려해도 되나요?

바로, **중간 상태에서 높이가 가장 높은 경우가 최적**이라는 것을 어렵지 않게 알 수 있을 것입니다.
우리가 시작 높이 X에서 시작해서 도착까지는, 날아가는 과정에서 높이가 내려가기만 하게 됩니다. 그리고 날아가면서 소요되는 시간과, 우리가 직접 JOI군을 움직여서 높이를 낮추는 경우는 둘이 동일한 시간이 들어가게 됩니다.

그러므로, 실제 우리가 고려해줘야 하는 경우는 바로 **올라가는 경우를 최소화하는 것**에 있다는 것을 어렵지 않게 이해할 수 있습니다.
이는 실제로 결과를 좌우하게 되는 요소가 되며, 올라가는 경우는 도착 나무에서 높이가 낮을 수록 더 커지게 됩니다.

즉, 우리의 목표는 중간 상태의 높이를 최대화하는 경우가 항상 최적이라는 것을 쉽게 이해할 수 있게 됩니다.

그렇다면, 실제 제약조건 중 이를 고려할 수 있는 것은 1, 2, 3번 중 어떠한 것이 될까요? 하나씩 살펴보도록 하겠습니다.

먼저, 첫번째 제약조건을 보겠습니다. 이는 어떠한 나무 쌍이 날아갈 수 있는지를 확인하는 조건이었습니다. 이 경우는 입력을 받는 도중에도 시작 나무의 키와 이동하는 데 걸리는 시간을 고려하는 것을 전처리해줄 수 있는 단순한 조건인 것을 확인할 수 있습니다.

그렇다면 두 번째 제약조건은 어떨까요?

우리는 1번 조건에서 걸러지지 않은 경우에는 어떠한 방법으로든 시작 나무에서 도착 나무로 이동하는 것이 가능합니다. 날아가기 전에 특정 높이만큼 올라가거나 내려가는 것을 취하는 것이 가능하기 때문입니다. 즉, 2번 조건에서는 일단 날아가는 것은 가능한 상황입니다.
또한, 우리가 특정 높이만큼 내려가는 것은 필수인 경우, 앞선 파악에 의해서 그저 **해당 목표 나무의 꼭대기로 움직인다**와 동일한 결과를 내는 것을 알 수 있어, 큰 고려대상이 아님을 확인할 수 있습니다.

이제는 실제 결과에 영향을 미치는 마지막 조건을 다루도록 하겠습니다.

마지막 조건의 경우, 시작 나무에서 '올라가야 한다'라는 조건을 주기 때문에 결과에 큰 영향을 미칠 수 있습니다. 우리는 중간에 올라가는 것을 함께 고려하게 된다면, 이에 소요되는 시간을 따로 고려해줘야하기 때문입니다.

그렇다면 이는 어떻게 해결할 수 있을까요?

정답은 바로, **중간에 올라가는 경우는 고려하지 않아도 된다**입니다.

그 이유는 다음과 같습니다.

먼저, 3번의 조건에서도 1번의 경우와 마찬가지로, 우리가 시작 나무에서 올라가기만 한다면 이동하는 것은 가능함을 알 수 있습니다.
그리고 이와 같이 시작 나무에서 올라가서 날아가게 된다면, 결과적으로 도착하는 나무에서는 높이가 항상 0이 된다는 것 또한 알 수 있습니다.
즉, 우리는 도착한 이후에도, 다른 나무로 날아가기 위해서는 해당 높이만킄 또다시 올라가는 것을 반복해야한다는 것입니다.

이것이 의미하는 바는, 우리가 한 번 3번 조건에 들어가게 된다면, 그 이후에는 항상 다음 나무의 높이 0에 도착하기 위해, 해당 거리만큼을 올라가야한다는 것과 동일하게 됩니다.

그렇다면, 이를 다음과 같이 보면 어떻게 될까요?

- 중간에 올라가야하는 경우를 고려하지 않고, 마이너스 높이로 생각한 이후, 마지막 나무에서 한 번에 올라가기

우리는 어차피 누적되어 계속해서 올라가야하는 경우, 이를 마지막 나무에서 한 번에 올라가는 것으로 처리해도 결과가 바뀌지 않는다는 것을 확인할 수 있습니다.
이를 이해하기 어렵다면, 직접 한 두 개의 나무 예제를 만들어서 생각해주셔도 괜찮습니다.

이렇게 고려해도 되는 이유는, 우리가 날아가는 거리는 항상 음수가 아니며, 우리가 목표로하는 나무의 꼭대기 위치도 항상 양수이기 때문에, 어떠한 경우든 **중간에 0 이하로 내려가는 경우, 마지막 나무까지 가기 위해서는 항상 올라가기만 해야 한다**라는 결론을 얻을 수 있기 때문입니다.

즉, 어차피 항상 올라가기만 해야하는 상황에 놓였다면, 우리는 이를 한 번에 계산해도 상관없다는 것을 알 수 있게 됩니다.

이를 통해 우리는 다음과 같은 풀이를 생각해줄 수 있게 됩니다.

- 나무 쌍이 이동 가능한지 조건만 파악해준 이후
- 이동하는 경우, 날아간 높이와 해당 나무의 높이 중 작은 값에 위치하게 되고
- 마지막 나무에서 한 번에 올라가기

위 조건들을 생각하게 되면, 우리는 특정 나무에 대해서 모든 높이를 고려할 필요 없이, 특정 나무로 이동할 수 있는 최대 높이에 대한 정보만 가지고 있어도 된다는 것을 알 수 있습니다.

이는 결국 최댓값을 유지하기 위한 다익스트라의 형태로 고려하는 것이 가능하게 되므로, 총 O(NlgM)의 시간복잡도로 해결할 수 있게 됩니다.

# [보석 도둑 - COCI 2010/2011 COCI 2013/2014 Contest #1 4번 LOPOV](https://www.acmicpc.net/problem/1202)

## 관찰

우리가 문제에서 주어진 조건을 통해서 살펴볼 수 있는 것이 있을까요? 

- 가방에는 아무리 많아도 최대 1개의 보석만을 넣을 수 있습니다.
- 가방에는 최대 무게가 Ci인 보석만을 넣을 수 있습니다.

위에 주어진 조건을 본다면, 가방 하나에는 아무리 많아도 1개의 보석만을 넣을 수 있으므로, 보석 하나를 가방에 넣게 된다면, 남아있는 보석과 가방은 이전에서 1개씩 사라진 것들 중 고려하면 된다는 것을 알 수 있습니다.

즉, 우리는 가방과와 보석들을 각각 한 개씩 매치하여 상덕이가 가지는 가격이 최대가 되도록 매치하는 문제로 표상할 수 있습니다.

그렇다면 주어진 보석들을 가방과와 어떻게 매치해주면 좋을까요?

앞선 예시에서 나왔던 보석들과 가방들을 살펴보겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_7.PNG)				

우리는 위의 5개의 보석이 있을 때, 각 가방들을 보석에 매치시키는 방법으로 문제를 해결할 수 있습니다. 그렇다면, 어떤 방법으로 매치를 진행할 수 있을까요?

우리는 가장 먼저, 가장 가격이가 큰 보석을 매치시켜주는 방법을 생각해볼 수 있습니다. 어차피 가격을를 최대화시키는 문제이므로, 가장 가격이가 큰 보석을 넣을 수 있다면 어느정도 합리적으로 보입니다. 이 방법대로 문제를 해결해보겠습니다.

먼저, 무게가 5인 가방을 보면, 모든 보석을 담을 수 있습니다. 그러므로 가장 가격이가 큰 5번을 가방에 매치 시켜주겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_8.PNG)

다음으로는 무게가 3인 가방을 보겠습니다. 이 때엔 가격이가 8인 1번 보석이 가장 좋아 보입니다. 2번 가방을 1번 보석에 매치 시켜주겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_9.PNG)

이제 무게가 1인 가방을 보겠습니다. 하지만 이 때에는 남은 보석들 모두 가방에 넣을 수 없으므로, 우리는 더 이상 보석을 담을 수 없습니다.

하지만, 만약 우리가 1번 보석을 무게가 1인 가방에 담았다면, 우리는 무게가 3인 가방에 2번 보석을 담아 25의 가격을 만들 수 있었습니다.

분명 가격이가 가장 큰 보석을 담는 것은 어느정도 합리적으로 보였었습니다. 그렇다면 왜 이런 결과가 나온 것일까요? 가격이 가장 큰 보석을 담는다는 접근이 잘못된 것일까요?

그 이유는 우리가 가방을 매치시킨 순서에 있습니다. 우리는 지금 가방의 무게에 상관없이 무작위 순서대로 매치를 시켰습니다. 이를 통해 우리는 ‘더 작은 가방에도 담을 수 있는 보석을 큰 가방에 담는다’라는 문제가 생겼습니다. 1번 보석은 무게가 1인 가방에도 담을 수 있었지만, 3인 가방에 담아, 1인 가방이 다른 보석을 담지 못했기 때문입니다.

## 풀이

그렇다면 이 문제를 어떻게 해결할 수 있을까요?

우리는 가방을 무게 순으로 정렬한 뒤, 무게가 작은 가방부터 매치를 진행하는 것으로 해결할 수 있습니다.

앞선 예시를 다시 한 번 살펴보겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_10.PNG)				

우리는 가방을 무게 순으로 정렬하여, 1, 3, 5인 가방을 보석에 매치시켜야 합니다.

먼저 무게 1 가방을 매치시킬 후보를 찾으면, (1, 8)만이 가능합니다. 그러므로 1번 보석을 1인 가방과와 매치해주겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_11.PNG)				

다음으로 무게 3인 가방을 보겠습니다. 후보는 (2, 7), (3, 6)이 있습니다. 이 때, 가격이가 가장 큰 것은 (2, 7)이므로 2번 보석에 매치시켜 주겠습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_12.PNG)

이제 무게 5인 가방을 보겠습니다. 이 때, 새로이 후보에 추가될 수 있는 보석으로는 (4, 9)와 (5, 10)이 있습니다. 이 때, 무게 3인 가방 후보였던 (3, 6)도 무게 5인 가방의 후보가 될 수 있을까요?

답을 ‘물론 될 수 있다’입니다. 우리는 가방들을 무게 순으로 보고 있기 때문에 항상 다음에 확인하게 되는 가방은 이전의 가방보다 더 무게가 커지게 됩니다. 즉, 우리는 현재 보고 있는 가방이가 이전 가방의 후보들 또한 항상 포함시킬 수 있음을 알 수 있습니다.

앞선 (1, 8)을 무게 3인 가방에 담아서, (2, 7), (3, 6)을 무게 1인 가방에 담을 수 없었던 경우같은 일은 발생할 수 없다는 것이죠.

결국, 우리는 무게가 작은 가방부터 순서대로, ‘자신이 담을 수 있는 보석 중 가장 가격이가 큰 보석을 담기’를 적용시킨다면, 어떠한 경우에도 항상 남아있는 후보군 들 중에서 가장 가격이가 큰 보석들을 담을 수 있습니다.

어차피 다음으로 오는 가방들에서 이전에 있던 후보군들을 모두 포함시킬 수 있는데, 굳이 현재 남아있는 가장 가격이가 큰 보석을 담지 않을 이유가 없음은 쉽게 알 수 있고, 이로써 현 방법이 최선임을 알 수 있습니다.
(만약 모든 가방들에 대해, 가격이가 최선이 아닌 (a1, b1)인 보석이 있고 이 보석을 c라는 가방에 담아야 최선이 된다면, c인 가방에서 (a1, b1)인 보석이 아닌 가격이가 더 크거나 같은 보석을 사용한다면 항상 가격의 합이 더 크거나 같아지므로, 항상 최선을 선택하는 것이 답이 됨을 알 수 있습니다)

이로써, 가방들을 순서대로 정렬하는데 O(KlgK), K개의 가방을 각각 N개의 보석에 매치시켜 주는데 O(NK)가 필요하므로, 시간복잡도는 $O(NK+KlgK)$가 걸리게 됩니다.

# [개미 - Waterloo's local Programming Contests 2004 September 19 B번 Ants](https://www.acmicpc.net/problem/4307)

## 관찰

어떤 개미는 다른 개미를 마주치는 것을 반복하여 계속해서 왼쪽, 오른쪽으로 방향을 바꾸게 될 수 있습니다. 개미가 항상 처음 방향대로만 이동하지 않을 수 있으므로, 우리가 어떤 개미가 막대 위를 언제 벗어나는지 알고 싶다면, 그 개미가 이동하게 되는 경로를 실제로 구하는 것으로 문제를 해결할 수 있습니다.

하지만 한 개미가 이동하게 되는 경로는 다른 개미들의 이동에 따라 바뀌고, 어디에서 마주치냐에 따라서도 달라지므로 각 개미들이 막대를 빠져나오는 시간을 하나하나 계산하기에는 어려움이 있을 수 있습니다.
그러나 만약 우리가 개미들이 이동하는 것을 시간에 따라 시뮬레이션 해줄 수 있다면, 어떤 시간에 어떤 개미가 어디에 있는지, 어디에서 마주치는지 알 수 있으므로 이를 쉽게 해줄 수 있습니다.

그러나 예시에서 봤듯, 개미들은 꼭 정수의 시간만큼씩 흐르지 않을 수 있어 정수 시간을 이용해 시뮬레이션 하는 것은 어려움이 있습니다. 그렇다면, 어떻게 시뮬레이션을 잘 할 수 있을까요?

이를 알기 위해서는 각 개미들이 언제 마주치는지 알아야 합니다. 처음 모든 개미들은 정수 위치에 있으므로 어떠한 두 개미도 늘 1, 2, 3 과같이 정수 거리 떨어져있게 됩니다. 이 때, 2 이상의 거리는 항상 1초 후에도 정수위치에 존재하고, 바로 마주치거나 아직 마주치지 못했을 것이므로, 거리 1의 경우를 생각합시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_13.PNG)

<center> 1, 2, 3의 위치에서 각각 오른쪽, 왼쪽, 왼쪽을 보는 개미들 </center>

1만큼 떨어진 두 개미는 0.5초 후에 0.5만큼 거리에서 마주치게 됩니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_14.PNG)

<center> 0.5초 후에 1.5에서 두 개미가 만나도, 3에 있던 개미는 2.5로 이동해 거리가 1만큼 멀다 </center>

이 때, 다른 개미들은 이 두 개미와 1 이상 떨어져있으므로, 다른 개미들은 두 개미가 마주친 위치에서 적어도 1이상 떨어져있게 됩니다. 즉, 우리는 두 개미가 마주친 이후 0.5초가 지나더라도 거리는 1만큼 밖에 차이가 나지 않으므로, 이 두 개미와 다른 개미들이 그 순간 마주치게 되거나, 만나지 않는 경우만 존재한다는 것을 알 수 있습니다. 즉, 우리는 개미들이 마주치는 순간은 항상 0.5초 단위로 나눌 수 있게 되어, 우리는 0.5초씩 진행하여 시뮬레이션 하는 것으로 모든 개미들이 막대를 나가는 순간을 계산해줄 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_15.PNG)

1.5의 개미와 2.5의 개미는 1만큼 떨어져있으므로, 0.5초 후에 마주침

이는 결국 모든 개미들의 0.5초후의 위치를 계산해주는 것을 반복하는 것이므로, (막대에서 빠져나가는 시간) * N 만큼의 시간이 걸리는 것으로, 문제를 해결할 수 있습니다.

## 풀이

사실 우리는 실제로 시뮬레이션 하지 않고, 약간의 관찰만을 해주게 되면, 문제를 쉽게 해결할 수 있습니다.
앞선 관찰에서 각 개미들의 위치를 알기 어려웠던 이유는 한 개미가 보고있는 방향을 바꾸는 일이 굉장히 많이 일어날 수 있어, 각 개미들이 어떤 경로를 통해 이동하는지 알기 쉽지 않았다는 점입니다. 하지만 우리에게 중요한 것은 각 개미가 어떤 경로로 언제 막대에서 떨어지는지가 아닌, 모든 개미가 막대에서 떨어지는 시간이라는 것을 이용하면, 문제를 좀 더 쉽게 생각할 수 있습니다.

아까의 그림 예시를 봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_11_16.PNG)

두 개미가 마주쳐서 1번 개미는 오른쪽을 보고 있다가, 1.5의 위치에서 마주쳐 왼쪽을 보고 이동하게 됩니다. 
하지만 이것을 개미의 번호가 없다고 생각하고 본다면 어떻게 될까요? 1번과 2번 개미는 서로 마주쳐 반대로 걸어갔지만, 만약 반대로 걸어가지 않고 그대로 걸어갔다면 어떻게 될까요?

그 결과는 위 그림과 하나도 빠짐없이 같아질 것입니다. 두 개미는 원래 걸어가던 대로 걸어가면서, 매겨져있던 번호만 바뀔 뿐, 마주친 이후에 왼쪽으로 이동하는 개미와 오른쪽으로 이동하는 개미가 한 마리씩이라는 점은 달라지지 않으므로, 그냥 지나쳐 간다 생각해도 문제가 없게 됩니다.

이를 이용하여, 모든 개미들에 대해, 다른 개미들이 없이 보고있는 방향으로 걷는다고 생각해도 모든 개미들이 막대에서 나가는 것에는 영향을 주지 않게 되어, 각 개미가 혼자 걸을 때 벗어나는 시간들 중 가장 큰 값이 되는 순간, 모든 개미들이 막대에서 벗어난다는 것을 알 수 있습니다.

결국 막대의 길이와 상관없이, 각 개미들과 막대의 거리만 중요하게 되므로, 총 O(N)에 문제를 해결할 수 있습니다.

# 코드

## Two Machines

```cpp
#include <bits/stdc++.h>
#define INF 1e9
using namespace std;

int n, res = 1e9;
int dp[300][70000];

int main(){
	int i, j, k, a, s;
	scanf("%d", &n);
	for(i = 1; i <= n; i++){
		scanf("%d %d", &a, &s);
		for(j = 0; j <= 250 * i; j++){
			dp[i][j] = dp[i-1][j] + s;
			if(j - a >= 0) dp[i][j] = min(dp[i][j], dp[i-1][j-a]);
		}
	}
	for(i = 0; i <= 250 * n; i++) res = min(res, max(dp[n][i], i));
	printf("%d", res);
	return 0;
}
```

## Byte Coin

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int n;
ll w, a, c = 1e9;

int main(){
	int i;
	scanf("%d %lld", &n, &w);
	for(i = 0; i < n; i++){
		scanf("%lld", &a);
		if(a > c) w = (w / c) * a + w % c;
		c = a;
	}
	printf("%lld", w);
}
```

## 보석 도둑

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

struct data{int m,v;};
ll sum;

int n,k;
int carr[300010];
data arr[300010];
bool compare(data d1,data d2){
    return d1.m<d2.m;
}
priority_queue <int,vector<int>,less<int>> pq;
int main(void){
    int j=0;
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++)scanf("%d %d",&arr[i].m,&arr[i].v);
    for(int i=0;i<k;i++)scanf("%d",&carr[i]);
    sort(arr,arr+n,compare);
    sort(carr,carr+k);
    for(int i=0;i<k;i++){
        while(j<n&&arr[j].m<=carr[i]){
            pq.push(arr[j++].v);

        }
        if(!pq.empty())sum+=pq.top(),pq.pop();
    }
    printf("%lld",sum);
    return 0;
}
```

## 개미

```cpp
#include <bits/stdc++.h>

using namespace std;

int T, l, n;

int main(){
	int i, min1, max1, a;
	scanf("%d", &T);
	while(T){
		scanf("%d %d", &l, &n); min1 = 0; max1 = 0;
		for(i = 0; i < n; i++){
			scanf("%d", &a);
			min1 = max(min1, min(a, l - a));
			max1 = max(max1, max(a, l - a));
		}
		printf("%d %d\n", min1, max1);
		T--;
	}
	return 0;
}
```
