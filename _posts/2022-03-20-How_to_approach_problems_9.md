---
layout: post
title:  "알고리즘 문제 접근 과정 9"
date:   2022-03-20 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 9

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [짐 정리 - KOI 2007 지역본선 중등부 4번](https://www.acmicpc.net/problem/2569)

## 풀이

문제를 간략화하기 위해, 짐들을 옮길 때 드는 힘을 생각하지 않고, 최소 몇 번 만에 짐을 옮겨 정렬할 수 있는지 위 그림을 예시로 확인해봅시다.

i) 각각의 짐들은 자기 위치에 있거나, 혹은 자신의 위치에 있지 않은 두 가지 경우가 있다. 자기 위치에 있는 짐은 어차피 옮겨봤자 그 위치로 오게 된 다른 짐과 자기 자신 모두 제 위치로 다시 돌아가야하므로 항상 횟수를 더 늘리게 되어 의미가 없다.
ii) 자신의 위치에 있지 않은 짐의 경우, 한 번 옮기는 것으로 자신의 위치로 돌아갈 수 있다. 이 때 옮겨진 다른 짐은 그 위치가 자신의 올바른 위치이거나 아닌 두 가지 경우가 있기 때문에, 한 번의 바꿈에 최소 1개, 최대 2개의 짐이 정리된다는 것을 알 수 있다.
iii) 만약 두 짐을 바꾸어도 둘 다 올바른 위치로 가지 않는 경우, 이 때에도 두 번의 바꾸기를 어차피 더 처리해야 하므로 횟수를 늘리게 되어 무의미한 바꿈이 된다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_1.PNG)

즉, 이를 통해 우리는 항상 한 번 바꿀 때, 적어도 하나의 짐은 정리될 수 있게 바꿔야한다는 것을 알 수 있다. 그럼 위 예시에서 최소 횟수로 바꾸어 짐을 정리해봅시다.

2번 짐의 경우 10번 짐의 위치로, 10번 짐은 5번, 5번 짐은 2번 짐의 위치로 이동해야합니다.
이를 그림으로 그리게 되면 2 -> 10 -> 5 -> 2로 이어지는 사이클이 만들어집니다.
 
![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_2.PNG)
 
이 때, 사이클의 한 선이 서로 잇지 않는 짐들을 옮기는 경우는 iii)번 경우와 같기 때문에 의미가 없게 됩니다. 즉, 우리는 항상 바꿀 때마다 간선의 양 옆에 해당하는 짐들을 바꾸는 것으로 짐을 정리할 수 있고, 최종적으로 필요한 연산의 수는 (사이클 간선의 수 – 1)이 됩니다(나머지 경로에서 짐들이 모두 바뀌기 때문에, 마지막 한 번 더 바꾸게 되면 두 짐은 한 번 더 바뀌게 된다).

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_3.PNG)

즉, 우리가 정리에 필요한 최소 연산은 위 방법으로 만든 (사이클 간선의 전체 수 – 사이클의 수)가 됩니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_4.PNG)

그렇다면, 이 때 힘을 고려하면 어떻게 바꿀 수 있을까요?
만약 한 사이클 내에 있는 짐들만 서로 교환해서 바꾼다면 어떻게 바꾸는 것이 좋을까요?

<center>EX) 2 – 6 – 1 – 4 – 9 – 10</center>

물론 여기에서 어떤 순서로든 항상 하나가 정렬되도록 바꾸면 5번만에 해결할 수 있습니다. 즉, 이 때 적어도 모든 짐들은 한 번씩 이동해야하므로 2 + 6 + 1 + 4 + 9 + 10의 비용은 최소한으로 들게 됩니다. 그렇다면 각 짐들을 정렬하기 위해 비교하는 다른 한 짐은 어떤걸 선택하는게 좋을까요?

위 사이클을 오른쪽으로 두 번 돌려봅시다.

<center>1 – 4 – 9 – 10 – 2 – 6</center>

이 때, 6번부터 1번과 바꾸기 시작한다면, 바꾸는 연산은

<center>6 – 1, 2 – 1, 10 – 1, 9 – 1, 4 – 1</center>

와같이 됩니다.

여기서 무언가 볼 수 있을까요?
나머지 한 쪽에는 1을 제외한 모든 짐들이 들어가고, 다른 한 쪽에는 1만을 들어가게 할 수 있습니다.
즉, 힘은 (모든 짐들의 합 + 다른 쪽 짐 * (바꾸는 횟수 – 1)) 만큼 필요합니다.
이 때, 다른쪽 짐을 항상 그 사이클 내 가장 작은 짐으로 고정해놓는다면 한 사이클 내에서만 짐을 바꾼다고 했을 때, 항상 최소로 바꿀 수 있습니다.

그렇다면, 모든 사이클에 대해 이 방법을 쓰는 것이 최소일까요?

다음 예시를 한 번 봅시다.

<center>100 – 101 – 102 – 103 – 104</center>
<center>1 – 2</center>

위와 같은 두 사이클이 존재한다고 할 때, 아래 사이클은 당연히 1 – 2를 바꾸는 것이 최적임을 알 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_5.PNG)
<center>아래 사이클을 바꾸는 방법</center>

그렇다면, 윗 사이클의 경우는 어떨까요?

앞서 한 것처럼 가장 작은 짐을 기준으로 하면 들어가는 힘은 (510 + 100 * 3) = 810이 들어갑니다.
하지만 다음과 같이 바꾸면 어떻게 될까요?

<center>1 – 100, 1 - 104, 1 – 103, 1 – 102, 1 – 101, 1 – 100</center>

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_6.PNG)
<center>1과 100을 바꾼 이후, 1을 이용해 윗 사이클을 정렬한 방법</center>

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_7.PNG)
<center>이후 마지막으로 1과 100을 한 번 더 바꿈으로 최종 정렬</center>

이 경우의 합은 (모든 짐들의 합 + 100 + 1 * 6) = 602만큼 들어가게 됩니다.

위 경우는 나머지 중에 가장 작은 짐을, 한 사이클 내 가장 작은 짐과 바꾸어 한 쪽 짐을 가장 작은 짐으로 고정시켜 정렬한 이후, 사이클이 정렬되고 나면 원래 사이클에 있던 짐과 다시 자리를 바꾸는 방법입니다. 이 경우, 전체 중 최소인 짐을 여러 번 쓰게 되지만, 그 짐의 무게 자체가 작을 경우 이득을 볼 수 있는 방법입니다.

그렇다면, 위 두 경우가 나머지 모든 경우들보다 항상 낫다고 말할 수 있을까요?

정렬을 할 때에는 항상

- 한 사이클 내 짐들만 이용하거나
- 다른 사이클 내 짐을 이용하는 것

이 두 가지가 있으므로, 각각의 경우에 가장 작은 짐을 쓰는 것은 항상 유의미하고, 이외의 경우들은 위 경우에 속하면서 값이 더 커진다는 것을 알 수 있습니다.
즉, 우리는 각 사이클 내 가장 작은 원소의 값과, 한 사이클의 크기와 원소들의 합, 모든 짐들 중 최솟값을 알고 있다면, 한 사이클을 정렬하는데 필요한 비용을 한 번의 계산만으로 알아낼 수 있습니다.

사이클을 찾아내는데 $O(N)$, 각 사이클을 탐색하는데 총 $O(N)$, 짐들의 원래 위치를 찾기 위해 정렬하는 시간 $O(NlgN)$이 필요하므로 최종 시간복잡도 $O(NlgN)$에 문제를 해결할 수 있습니다.

# [햄버거 분배 - KOI 2020 1차 대회 고등부 2번](https://www.acmicpc.net/problem/19941)

## 관찰

주어진 문제를 해결할 수 있는 가장 쉬운 방법을 생각해봅시다.

우리는 햄버거와 사람의 위치, 인접한 햄버거를 먹을 수 있는 반경 K가 주어집니다.
결국, 우리는 매 사람과 햄버거들이 자신과 연결될 수 있는 반경 내에 있는 집합들을 구해줄 수 있고, 이들 중 최대로 연결할 수 있는 때 연결의 수를 구하면 됩니다.

만약 주어진 문제에서 i명의 사람과 j개의 햄버거가 존재한다고 합시다. 이 때, 우리는 i명의 사람과 j개의 햄버거를 모두 매치시켜보는 방법을 생각해볼 수 있습니다.
즉 모든 가능한 매치 중, 실제로 연결이 가능한 햄버거와 사람의 수를 세서, 이들 중 최댓값을 이용하여 답을 구해낼 수 있습니다.

일반성을 잃지 않고 i >= j라 가정할 때, 가능한 매치의 수는 $_{i}P_{j}$ 가 되므로, 이들 연결을 모두 해보는 것으로도 문제를 해결할 수는 있습니다.
허나 순열의 경우, 수가 커지면 기하급수적으로 증가하므로, n이 증가할 때에 문제를 해결하기 어려울 수 있습니다.

## 풀이

우리가 어떤 문제에 접근할 때에는, 무언가를 시작하는 대상이 무엇인가부터 접근해보는 것이 상당히 많은 경우에 좋은 영감을 줄 수 있습니다.

앞선 문제에서 가장 해결하기 힘들었던 부분은 바로 **어떤 햄버거와 어떤 사람을 연결할 것인가?** 에 관한 문제였습니다.
모든 사람과 햄버거에 대해서 생각해보니 너무나도 많은 시간이 걸리게 되므로, 우리는 특별한 방법으로 햄버거와 사람을 연결시켜줄 방법을 찾아야합니다.

이를 해결하기 위해, 우리는 한 번 ‘처음으로 햄버거와 사람이 연결되는 상황’을 생각해볼 수 있습니다.

식탁의 가장 앞에 놓여있는 햄버거를 기준으로 한 번 생각해봅시다.

가장 앞에 놓인 햄버거를 먹을 수 있는 사람들이 식탁의 앞쪽에 가까운 순서대로 a, b, c, d 세 사람이라고 합시다.
이 때, 어떤 사람이 햄버거를 먹어야 가장 좋은 연결이라고 볼 수 있을까요?

굳이 햄버거와 사람을 연결할 수 있는데 연결하지 않는 것은 좋지 않다는 것을 쉽게 알 수 있습니다.
만약 a, b, c, d 모두 다른 햄버거와 연결해서 최대 사람 수를 만들 수 있다면, 우리는 그 중 a, b, c, d 와 연결된 한 쌍을 현재 햄버거와 교체해도, 최대 사람 수 자체는 변하지 않아 적어도 같은 결과를 만들 수 있기 때문입니다.
즉, 우리는 적어도 이들 중 한 명과 매칭하는 것은 사람 수를 최대로 만들기 위해 필요한 것임을 알 수 있습니다.

그렇다면 이 중 어떤 사람과 연결해야 좋은 결과를 얻을 수 있을까요?
이는 앞선 문제에서, 햄버거와 사람이 K 이하의 반경에 있는 경우에만 연결할 수 있다는 것을 이용하여 좋은 접근을 얻을 수 있습니다.

이를 해결하기 위해, 첫 햄버거 다음에 있는 햄버거들이, a, b, c, d 후보 중 어떤 사람들을 연결할 수 있는지 생각해봅시다. 

1. 어떤 햄버거가 a와 연결할 수 있다면, 그 햄버거는 b, c, d 또한 연결할 수 있습니다. 현재 우리가 보는 햄버거가 가장 앞에 있는 햄버거이기 때문에, 이 뒤에 있는 햄버거의 왼쪽 반경이 a를 커버하고 있다면, b, c, d 또한 커버할 수 있습니다.
2. 어떤 햄버거가 a와 연결 불가하고, b를 연결할 수 있다면, 앞선 방식처럼 생각하여 그 햄버거가 c, d 또한 연결할 수 있음을 알 수 있습니다.
3. 어떤 햄버거가 a, b와 연결 불가하고 c를 연결할 수 있다면, d 또한 연결할 수 있습니다.
4. 어떤 햄버거가 d만 연결할 수 있을 수 있습니다.
5. 어떤 햄버거가 a, b, c, d 모두가 연결 불가능할 수 있습니다.

이 중, 5번의 경우, 우리가 첫 햄버거를 어떤 사람과 연결하더라도 이후의 연결에 영향이 없습니다.

이를 제외한 나머지 경우들을 살펴봅시다.

우리는 여기에서, d는 1, 2, 3, 4번에 해당하는 햄버거들과 모두 연결이 될 수 있으며, c는 1, 2, 3번, b는 1, 2번, a는 1번의 경우에 해당하는 햄버거들과만 연결될 수 있음을 알 수 있습니다.

우리는 현재 햄버거에서의 연결이, 이후에 나오는 다른 햄버거들의 연결 후보를 줄일 수 있기 때문에 문제가 되었습니다.
허나 이렇게 연결관계를 살펴보게 되면, d를 선택하여 연결할 경우, a, b, c를 선택할 때보다 항상 더 같거나 많은 연결 후보를 줄이게 되며, c를 선택할 경우 a, b, b를 선택할 경우 a를 선택할 때보다 항상 더 많은 연결 후보를 줄이게 된다는 것을 알 수 있습니다. 이들은 모두 포함 관계이기 때문에, 항상 a < b < c < d 순으로 더 많은 후보를 줄인다는 것을 알 수 있습니다.

즉, 우리는 4명의 매치 가능한 사람 후보가 있을 때, 앞으로의 연결에서 후보를 적게 줄이기 위해서는 항상 첫 번째 햄버거가 연결 가능한 사람 중, 식탁의 시작에 가장 가까운 위치에 있는 사람인 a와 연결하는 것이 가장 좋다는 것을 알 수 있었습니다. 이는 4명을 더 많은 후보로 확장하거나 줄여도 항상 성립한다는 것을 어렵지 않게 보일 수 있습니다.

이렇게 첫 번째 햄버거의 연결을 하나 확인할 수 있었습니다. 그렇다면 나머지 햄버거의 연결은 어떻게 될까요?

우리가 첫 햄버거의 연결을 무조건 고정시키게 되면, 해당 햄버거와 사람은 모든 후보에서 제거된 상태로 볼 수 있습니다. 그렇다면 이 때에 남은 햄버거 중 가장 앞에 있는 햄버거에서 시작한다면, 우리는 이를 다시 첫 햄버거로 보고 문제를 접근할 수 있습니다.

결국 이 문제를 매 순간마다 가장 앞에 있는 햄버거를 매치시키는 문제로 본다면, 항상 가능한 후보들 중 가장 앞에 있는 사람을 매치시켜주는 방법이 항상 최선이라는 것을 알 수 있게 됩니다.

이를 매 햄버거마다 앞에 있는 사람을 매치시키는 방법으로 구현하면 최대 햄버거 $O(N)$, 사람 수 $O(N)$이므로 총 $O(N^2)$에 해결할 수 있습니다.

허나 우리는 앞선 방법으로 매 순간 가장 앞에 있는 햄버거와, 그 햄버거와 연결할 수 있는 가장 앞에 있는 사람만이 중요함을 알게 되었으므로, 매 상태에서 가장 앞에 있는 햄버거와 사람의 위치를 기록하는 두 개의 포인터(two pointer)를 이용하면, $O(N)$에 해결할 수 있습니다.

# 코드

## 버스 노선

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Data{ int x, y, idx; } arr[2000010];

int n, m, cnt;
int carr[500010];

bool compare(Data d1, Data d2){
	if(d1.x == d2.x) return d1.y > d2.y;
	return d1.x < d2.x;
}
int main(){
	int i, now;
    scanf("%d %d",&n, &m);
    for(i = 0; i < m; i++){
        scanf("%d %d",&arr[cnt].x, &arr[cnt].y);
        arr[cnt].idx = i + 1;
        if(arr[cnt].x > arr[cnt].y){
            arr[cnt].y += n;
            cnt++;
        }
        else{
            arr[cnt + 1].x = arr[cnt].x + n;
            arr[cnt + 1].y = arr[cnt].y + n;
            arr[cnt + 1].idx = i + 1;
            cnt += 2;
        }
    }
	sort(arr,arr+cnt,compare);
	now = arr[0].y;
    for(i = 1; i < cnt; i++){
        if(arr[i].y <= now) carr[arr[i].idx] = 1;
        now = max(arr[i].y, now);
    }
	cnt = 0;
    for(i = 1; i <= m; i++){
        if(!carr[i]) printf("%d ", i);
    }
	return 0;
}
```

## 햄버거 분배

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, res;
char arr[20010];

int main(){
	int i = 0, j = 0;
	scanf("%d %d %s", &n, &k, arr);
	while(i < n){
		while(j < i - k) j++;
		if(arr[i] == 'P'){
			while(j <= i + k && j < n){
				if(arr[j] == 'H'){ res++, j++; break; }
				j++;
			}
		}
		i++;
	}
	printf("%d", res);
	return 0;
}
```
