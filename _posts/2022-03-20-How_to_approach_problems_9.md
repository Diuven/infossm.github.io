---
layout: post
title:  "알고리즘 문제 접근 과정 9"
date:   2022-03-20 08:00:00
author: VennTum
tags: [data-structure, algorithm]
---

# 알고리즘 문제 접근 과정 9

이번 포스트에서도 '알고리즘 문제 접근 방법' 시리즈에서 진행했듯이 특정 문제를 해결하기 위해 가장 낮은 단계의 접근에서부터 최종 해법까지 해결해나가는 과정을 작성합니다.

최대한 다양한 유형의 문제들을 다루어, 많은 문제 유형에서의 접근 방법에 대한 실마리를 드리는 역할을 하려 합니다.

# [짐 정리 - KOI 2007 지역본선 중등부 4번](https://www.acmicpc.net/problem/2569)

## 풀이

문제를 간략화하기 위해, 짐들을 옮길 때 드는 힘을 생각하지 않고, 최소 몇 번 만에 짐을 옮겨 정렬할 수 있는지 위 그림을 예시로 확인해봅시다.

i) 각각의 짐들은 자기 위치에 있거나, 혹은 자신의 위치에 있지 않은 두 가지 경우가 있다. 자기 위치에 있는 짐은 어차피 옮겨봤자 그 위치로 오게 된 다른 짐과 자기 자신 모두 제 위치로 다시 돌아가야하므로 항상 횟수를 더 늘리게 되어 의미가 없다.
ii) 자신의 위치에 있지 않은 짐의 경우, 한 번 옮기는 것으로 자신의 위치로 돌아갈 수 있다. 이 때 옮겨진 다른 짐은 그 위치가 자신의 올바른 위치이거나 아닌 두 가지 경우가 있기 때문에, 한 번의 바꿈에 최소 1개, 최대 2개의 짐이 정리된다는 것을 알 수 있다.
iii) 만약 두 짐을 바꾸어도 둘 다 올바른 위치로 가지 않는 경우, 이 때에도 두 번의 바꾸기를 어차피 더 처리해야 하므로 횟수를 늘리게 되어 무의미한 바꿈이 된다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_1.PNG)

즉, 이를 통해 우리는 항상 한 번 바꿀 때, 적어도 하나의 짐은 정리될 수 있게 바꿔야한다는 것을 알 수 있다. 그럼 위 예시에서 최소 횟수로 바꾸어 짐을 정리해봅시다.

2번 짐의 경우 10번 짐의 위치로, 10번 짐은 5번, 5번 짐은 2번 짐의 위치로 이동해야합니다.
이를 그림으로 그리게 되면 2 -> 10 -> 5 -> 2로 이어지는 사이클이 만들어집니다.
 
![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_2.PNG)
 
이 때, 사이클의 한 선이 서로 잇지 않는 짐들을 옮기는 경우는 iii)번 경우와 같기 때문에 의미가 없게 됩니다. 즉, 우리는 항상 바꿀 때마다 간선의 양 옆에 해당하는 짐들을 바꾸는 것으로 짐을 정리할 수 있고, 최종적으로 필요한 연산의 수는 (사이클 간선의 수 – 1)이 됩니다(나머지 경로에서 짐들이 모두 바뀌기 때문에, 마지막 한 번 더 바꾸게 되면 두 짐은 한 번 더 바뀌게 된다).

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_3.PNG)

즉, 우리가 정리에 필요한 최소 연산은 위 방법으로 만든 (사이클 간선의 전체 수 – 사이클의 수)가 됩니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_4.PNG)

그렇다면, 이 때 힘을 고려하면 어떻게 바꿀 수 있을까요?
만약 한 사이클 내에 있는 짐들만 서로 교환해서 바꾼다면 어떻게 바꾸는 것이 좋을까요?

<center>EX) 2 – 6 – 1 – 4 – 9 – 10</center>

물론 여기에서 어떤 순서로든 항상 하나가 정렬되도록 바꾸면 5번만에 해결할 수 있습니다. 즉, 이 때 적어도 모든 짐들은 한 번씩 이동해야하므로 2 + 6 + 1 + 4 + 9 + 10의 비용은 최소한으로 들게 됩니다. 그렇다면 각 짐들을 정렬하기 위해 비교하는 다른 한 짐은 어떤걸 선택하는게 좋을까요?

위 사이클을 오른쪽으로 두 번 돌려봅시다.

<center>1 – 4 – 9 – 10 – 2 – 6</center>

이 때, 6번부터 1번과 바꾸기 시작한다면, 바꾸는 연산은

<center>6 – 1, 2 – 1, 10 – 1, 9 – 1, 4 – 1</center>

와같이 됩니다.

여기서 무언가 볼 수 있을까요?
나머지 한 쪽에는 1을 제외한 모든 짐들이 들어가고, 다른 한 쪽에는 1만을 들어가게 할 수 있습니다.
즉, 힘은 (모든 짐들의 합 + 다른 쪽 짐 * (바꾸는 횟수 – 1)) 만큼 필요합니다.
이 때, 다른쪽 짐을 항상 그 사이클 내 가장 작은 짐으로 고정해놓는다면 한 사이클 내에서만 짐을 바꾼다고 했을 때, 항상 최소로 바꿀 수 있습니다.

그렇다면, 모든 사이클에 대해 이 방법을 쓰는 것이 최소일까요?

다음 예시를 한 번 봅시다.

<center>100 – 101 – 102 – 103 – 104</center>
<center>1 – 2</center>

위와 같은 두 사이클이 존재한다고 할 때, 아래 사이클은 당연히 1 – 2를 바꾸는 것이 최적임을 알 수 있습니다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_5.PNG)
<center>아래 사이클을 바꾸는 방법</center>

그렇다면, 윗 사이클의 경우는 어떨까요?

앞서 한 것처럼 가장 작은 짐을 기준으로 하면 들어가는 힘은 (510 + 100 * 3) = 810이 들어갑니다.
하지만 다음과 같이 바꾸면 어떻게 될까요?

<center>1 – 100, 1 - 104, 1 – 103, 1 – 102, 1 – 101, 1 – 100</center>

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_6.PNG)
<center>1과 100을 바꾼 이후, 1을 이용해 윗 사이클을 정렬한 방법</center>

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_7.PNG)
<center>이후 마지막으로 1과 100을 한 번 더 바꿈으로 최종 정렬</center>

이 경우의 합은 (모든 짐들의 합 + 100 + 1 * 6) = 602만큼 들어가게 됩니다.

위 경우는 나머지 중에 가장 작은 짐을, 한 사이클 내 가장 작은 짐과 바꾸어 한 쪽 짐을 가장 작은 짐으로 고정시켜 정렬한 이후, 사이클이 정렬되고 나면 원래 사이클에 있던 짐과 다시 자리를 바꾸는 방법입니다. 이 경우, 전체 중 최소인 짐을 여러 번 쓰게 되지만, 그 짐의 무게 자체가 작을 경우 이득을 볼 수 있는 방법입니다.

그렇다면, 위 두 경우가 나머지 모든 경우들보다 항상 낫다고 말할 수 있을까요?

정렬을 할 때에는 항상

- 한 사이클 내 짐들만 이용하거나
- 다른 사이클 내 짐을 이용하는 것

이 두 가지가 있으므로, 각각의 경우에 가장 작은 짐을 쓰는 것은 항상 유의미하고, 이외의 경우들은 위 경우에 속하면서 값이 더 커진다는 것을 알 수 있습니다.
즉, 우리는 각 사이클 내 가장 작은 원소의 값과, 한 사이클의 크기와 원소들의 합, 모든 짐들 중 최솟값을 알고 있다면, 한 사이클을 정렬하는데 필요한 비용을 한 번의 계산만으로 알아낼 수 있습니다.

사이클을 찾아내는데 $O(N)$, 각 사이클을 탐색하는데 총 $O(N)$, 짐들의 원래 위치를 찾기 위해 정렬하는 시간 $O(NlgN)$이 필요하므로 최종 시간복잡도 $O(NlgN)$에 문제를 해결할 수 있습니다.

# [새로운 님게임 - 2019년 한국정보올림피아드 1차대회 고등부 문제 유형2 7번](https://koi.or.kr/koi/2019/1/)

해당 문제는 필기 문제이므로, 임의의 문제 상황을 만들어 설명하겠습니다.

## 문제

알고는 리즘이와 님게임을 하는 중이다.

님게임이란, 2개의 각 줄에 바둑돌을 n개씩 두고, 한 사람이 한 줄을 선택하고, 그 줄에서 원하는 만큼의 바둑돌을 가져가고, 그 다음 사람이 똑같은 일을 수행해나가다가, 마지막 바둑돌을 가져가는 사람이 지는 게임이다.

알고와 리즘이는 님게임을 하다가, 이 게임이 너무 쉽다는 것을 알게되고, 금방 흥미를 잃게 되었다.

둘의 게임을 지켜보던 해결이는, 알고와 리즘이에게 ‘새로운 님게임’을 하자는 의견을 제시했다.

새로운 님게임이란, 이전과 같이 2개의 각 줄에 n개의 바둑돌이 일렬로 놓여있으며 한 줄을 선택하여 돌을 가져가며, 가져가는 돌의 수는 제약이 없다.

첫 줄을 선택하여 돌을 가져가는 경우, 이전과 동일하게 그 줄에서만 돌을 가져가게 되지만,
만약 두 번째 줄에서 선택하여 돌을 가져가는 경우, 두 번째 줄에 남아있는 돌의 수가 첫 번째 남아있는 돌의 수보다 적다면, 첫 줄의 돌의 수를 두 번째 줄의 돌의 수와 같게 되도록 돌을 추가로 더 가져가야한다.

새로운 님게임을 들은 알고와 리즘이는 재미있을 것 같다고 생각하여 게임을 하게 되었다. 이를 접한 알고와 리즘은 게임을 바로 이해하고 재미있게 하게되었다.

둘이 게임을 하는 것을 보고있는 해결이는, 둘이 게임을 하고있는 도중에, 누가 이길지 예측하고싶어하지만, 해결이는 게임을 잘 이해하지 못하여 누가 이길지 알지 못해, 도움을 요청했다.

첫 줄과 두 번째 줄에 놓여있는 돌의 수가 주어지며, 알고가 돌을 가져갈 차례일 때, 알고와 리즘이 중 누가 이길지 해결이에게 알려주자.

## 예시

첫 줄에 돌이 1개, 두 번째 줄에 돌이 2개라면 알고가 어떻게 해도 리즘이를 이길 수 없으므로, 리즘이가 이기게 된다.

## 관찰

우리가 흔히 상대방이 어떤 식으로 게임을 진행할지 알기 어려운 경우에 항상 최선을 다해서 게임을 진행한다는 형태의 문제를 접하고, 그 게임의 필승전략을 알지 못한다면, 상대방이 진행할 수 있는 경우가 가장 적은 작은 문제상황에서부터 접근을 해야합니다.

이 때, 작은 상태에서 먼저 게임을 시작하는 사람이 어떻게 해도 지는지, 혹은 어떻게 해도 지는지, 어떻게 상태를 만들면 이기는지에 대한 정보를 아는 것이 중요합니다.

주어진 예시인 각 줄에 1, 2 개의 돌이 있는 경우부터 살펴보겠습니다.
각 줄의 돌의 수를 (a, b)의 형태로 나타내겠습니다.

만약 (1, 2)의 상태에서 알고가 첫 줄의 돌을 가져가 (0, 2)가 된다면, 리즘이는 (0, 1)을 만들어 게임을 이길 수 있고, 알고가 (1, 1)의 상태로 만들더라도 리즘이가 (0, 1)의 상태를 만들면 이기므로, 알고는 어떻게해도 게임을 이길 수가 없습니다.

하지만 이 말은, 만약 알고가 어떤 돌의 상황에서 돌을 가져가서 리즘이한테 (1, 2)인 돌의 상태를 준다면, 알고가 무조건 승리한다는 말이 되기도 합니다.

즉, 우리는 항상 필승을 할 수 있는 상태로 ‘상대에게 (1, 2)를 준다’ 라는 한 경우를 찾아볼 수 있었습니다.

그렇다면, 항상 알고가 이길 수 있는 상태들을 찾아볼 수 있을까요?

우리는 첫 줄에서 원하는 만큼 돌을 가져갈 수 있기 때문에, 1보다 큰 수 a에 대해, (a, 2)의 상태인 경우 항상 알고가 첫 줄에서 a-1개의 돌을 가져가 (1, 2)의 돌을 리즘이한테 넘겨줘 게임을 이길 수 있습니다.

다만, 새로운 님게임의 조건 때문에 항상 첫 돌의 수가 두 번째 돌의 수보다 많은 경우는 없으므로, 알고가 이길 수 있는 조건을 현재 (2, 2)가 유일할 것입니다.

또는 2보다 큰 b에 대해서, (1, b)의 상태일 때 b-2개의 돌을 알고가 가져가서 이길 수 있으므로, 알고는 (2, 2), 혹은 (1, b)의 상태에서 게임을 이길 수 있습니다.

즉, 리즘이는 알고에게 (2, 2), 또는 (1, b)를 넘겨주는 상황이 항상 게임을 지는 경우임을 알 수 있습니다.

우리는 이처럼, 우리가 고려할 수 있는 작은 상태에서부터 어떤 상태들의 결과를 알 수 있는지 차근차근 생각해볼 수 있습니다.

## 풀이

이제 우리는 (2, 2), (1, b)의 경우 알고가 이길 수 있다는 사실을 알게 되었습니다. 우리는 이것을 확장하여 나중에 (a, b)에 해당하는 판의 승자를 알 수 있다면, 어떠한 경우에서도 답을 알아낼 수 있습니다.

앞선 관찰의 확장방법과 동일하게 한 단계씩 생각해봅시다.

만약 알고가 (2, b)의 판을 가지고 있다면 어떻게 될까요?
첫 줄에서 1개의 돌을 가져가면, 리즘이가 두 번째 둘의 돌을 1개 빼고 모두 가져가면 되므로 안됩니다.
또한, 두 번째 줄의 돌을 가져가 (2, 2), (1, 1)의 돌만 남겨놓더라도 항상 지게 됩니다. 즉, 우리는 상대방이 가질 때 가장 어려운 상태를 만들어서 돌려줘야합니다.

만약 b가 3이라면 어떻게 될까요? 어떻게 해도 알고는 (1, 1), (2, 2), (1, 3)의 상태를 벗어날 수 없고, 이 상태는 모두 상대방의 승리가 보장되어있습니다. 즉, 우리는 (2, 3)의 경우 항상 진다는 것을 알 수 있습니다.

그렇다면, b가 4 이상이라면? 알고가 (2, 3)의 상태를 만들어서 리즘이한테 넘겨주면, 알고가 승리하게 됩니다! 우리는 새로운 상태로, (2, 3)의 상태가 필패임을 찾았습니다.

(3, b)의 경우까지 한 번 더 고려해보도록 합시다.
만약 (3, 3)이라면 (2, 3)을 만들어 상대를 이길 수 있게 되며,
(3, 4)라면 (2, 4)를 만들어도 리즘이가 (2, 3)을 만들며 지고, (3, 3)을 만들어도 지며, 나머지 상태들 모두 진다는 것을 이미 이전에 확인한 적이 있어서, (3, 4)는 필패임을 알 수 있습니다.
(3, 4)가 필패이므로, 우리는 (3, b)에 대해 b - 4개의 돌을 두 번째 줄에서 가져가면 항상 필승이 됨을 알 수 있습니다!

우리가 구한 필승, 필패 상태를 판에 나타내봅시다.

![](/assets/images/VennTum/How_to_approach/How_to_approach_problems_9_8.PNG)

우리가 구한 알고가 승리, 패하는 상태들을 나타낸 표입니다.

혹시, 이 규칙은 우연일까요? 우리가 (a, a+1)인 상태의 판은 항상 지고, 나머지의 경우 이기는 것이 우연일까요?

결과부터 이야기하자면 절대 우연이 아닙니다.

이는 귀납적으로 증명할 수 있습니다.

우리는 이미 관찰 과정을 통해, (1, 1)이 필승상황, (1, 2)가 항상 필패상황이라는 것을 알 수 있었습니다. 이를 이용하여 우리는 다음 3가지를 증명하도록 합시다.

- (a, a+1)이 필패상태라면, (a+1, a+1)은 필승상태이다
- (a, a+1)이 필패상태라면, (a, a+b) (b >= 2)은 필승상태이다.
- 1, 2번을 만족한다면, (a+1, a+2)는 필패상태이다

위 3가지를 증명한다면, 우리는 (1, 2)이 필패상황임을 이용하여 (2, 2)가 필승, (1, 3) 이후는 필승임 알 수 있고, 새로 (2, 3)이 필패임을 통해 이를 무한히 반복하여 항상 (a, a+1)을 제외하고는 필승상태임을 증명할 수 있습니다.

첫 번째부터 증명하겠습니다. (a, a+1)이 필패라면, (a+1, a+1)에서 첫 번째 줄에서 돌 한 개를 가져가서 항상 (a, a+1)을 상대에게 넘겨줄 수 있으므로,  상대는 필패하여 나는 필승할 수 있습니다.

두 번째 상태의 경우, (a, a+1)이 필패라면, (a, a+b)에서 두 번째 줄에서 b - 1개의 돌을 가져가면 상대에게 필패상태를 줄 수 있어, 나는 필승하게 됩니다.

이제 문제의 첫 번째를 증명하겠습니다. 현재 a보다 작거나 같은 c들에 대해서는, 항상 (c, c+1)을 제외하고는 (a+1, a+2)보다 작은 상태들에 대해 항상 먼저 게임을 하는 사람이 필승이라는 점이 귀납적으로 보장되었다고 합시다.

이 때, (a+1, a+2)에서 할 수 있는 경우들을 하겠습니다.

두 번째 줄에서 1개 이상의 돌을 가져간다면 항상 특별한 (c, c)의 상태가 되므로, 상대가 필승이 되어 먼저 게임을 한 사람은 지게됩니다.
첫 번째 줄에서 1개 이상의 돌을 가져간다면, 항상 c보다 2 이상 큰 d에 대해 (c, d)의 상태가 되므로, 이는 2번에 해당하는 경우이므로 상대방이 필승이 되어, 먼저한 사람은 지게됩니다.

즉, 어떻게 해도 먼저한 사람은 게임을 지게 되므로, (a+1, a+2)는 필패가 됩니다.

이를 통해 모든 경우가 다 귀납적으로 해결이 되어, 항상 (a, a+1)의 꼴을 제외하고는 먼저한 사람이 게임을 이기게 되며, 이 경우는 항상 게임을 지게 됩니다.

이를 이용하여 입력 상황을 구분해주면 되며, 우리는 $O(1)$에 문제를 해결할 수 있습니다.

# 코드

## 버스 노선

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Data{ int x, y, idx; } arr[2000010];

int n, m, cnt;
int carr[500010];

bool compare(Data d1, Data d2){
	if(d1.x == d2.x) return d1.y > d2.y;
	return d1.x < d2.x;
}
int main(){
	int i, now;
    scanf("%d %d",&n, &m);
    for(i = 0; i < m; i++){
        scanf("%d %d",&arr[cnt].x, &arr[cnt].y);
        arr[cnt].idx = i + 1;
        if(arr[cnt].x > arr[cnt].y){
            arr[cnt].y += n;
            cnt++;
        }
        else{
            arr[cnt + 1].x = arr[cnt].x + n;
            arr[cnt + 1].y = arr[cnt].y + n;
            arr[cnt + 1].idx = i + 1;
            cnt += 2;
        }
    }
	sort(arr,arr+cnt,compare);
	now = arr[0].y;
    for(i = 1; i < cnt; i++){
        if(arr[i].y <= now) carr[arr[i].idx] = 1;
        now = max(arr[i].y, now);
    }
	cnt = 0;
    for(i = 1; i <= m; i++){
        if(!carr[i]) printf("%d ", i);
    }
	return 0;
}
```

## 햄버거 분배

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, res;
char arr[20010];

int main(){
	int i = 0, j = 0;
	scanf("%d %d %s", &n, &k, arr);
	while(i < n){
		while(j < i - k) j++;
		if(arr[i] == 'P'){
			while(j <= i + k && j < n){
				if(arr[j] == 'H'){ res++, j++; break; }
				j++;
			}
		}
		i++;
	}
	printf("%d", res);
	return 0;
}
```
